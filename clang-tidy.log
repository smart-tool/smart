clang-tidy source/*.c source/algos/*.c
source/algos/sebom.c:48:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   48 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sebom.c:32:7: note: Assuming 'm' is >= 2
   32 |   if (m < 2)
      |       ^~~~~
source/algos/sebom.c:32:3: note: Taking false branch
   32 |   if (m < 2)
      |   ^
source/algos/sebom.c:37:15: note: Assuming the condition is false
   37 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/sebom.c:37:3: note: Loop condition is false. Execution continues on line 41
   37 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sebom.c:41:3: note: Loop condition is false. Execution continues on line 44
   41 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sebom.c:45:8: note: The value 2147483647 is assigned to 'i'
   45 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/sebom.c:45:3: note: Loop condition is true.  Entering loop body
   45 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/sebom.c:48:17: note: Array access results in an undefined pointer dereference
   48 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sfbom.c:46:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   46 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sfbom.c:34:15: note: Assuming the condition is false
   34 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/sfbom.c:34:3: note: Loop condition is false. Execution continues on line 38
   34 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sfbom.c:39:3: note: Loop condition is false. Execution continues on line 42
   39 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sfbom.c:43:8: note: Value assigned to 'i'
   43 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/sfbom.c:43:15: note: Assuming 'i' is > 0
   43 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/sfbom.c:43:3: note: Loop condition is true.  Entering loop body
   43 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/sfbom.c:46:17: note: Array access results in an undefined pointer dereference
   46 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/simon.c:56:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   56 |   memset(L, 0, (m - 2) * sizeof(List));
      |   ^~~~~~
source/algos/simon.c:56:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   56 |   memset(L, 0, (m - 2) * sizeof(List));
      |   ^~~~~~
source/algos/simon.c:97:3: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   97 |   END_SEARCHING
      |   ^
source/algos/include/main.h:53:5: note: expanded from macro 'END_SEARCHING'
   53 |     timer_stop(_timer);                                                        \
      |     ^
source/algos/simon.c:84:9: note: Calling 'preSimon'
   84 |   ell = preSimon(x, m, L);
      |         ^~~~~~~~~~~~~~~~~
source/algos/simon.c:58:15: note: Assuming 'i' is < 'm'
   58 |   for (i = 1; i < m; ++i) {
      |               ^~~~~
source/algos/simon.c:58:3: note: Loop condition is true.  Entering loop body
   58 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/simon.c:60:13: note: '?' condition is true
   60 |     cell = (ell == -1 ? NULL : L[k]);
      |             ^
source/algos/simon.c:62:9: note: Assuming the condition is false
   62 |     if (x[i] == x[k + 1])
      |         ^~~~~~~~~~~~~~~~
source/algos/simon.c:62:5: note: Taking false branch
   62 |     if (x[i] == x[k + 1])
      |     ^
source/algos/simon.c:65:7: note: Calling 'setTransitionSimon'
   65 |       setTransitionSimon(i - 1, k + 1, L);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/simon.c:44:16: note: Memory is allocated
   44 |   cell = (List)malloc(sizeof(struct _cell));
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/simon.c:45:7: note: Assuming 'cell' is not equal to NULL
   45 |   if (cell == NULL)
      |       ^~~~~~~~~~~~
source/algos/simon.c:45:3: note: Taking false branch
   45 |   if (cell == NULL)
      |   ^
source/algos/simon.c:65:7: note: Returned allocated memory via 3rd parameter
   65 |       setTransitionSimon(i - 1, k + 1, L);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/simon.c:66:5: note: Loop condition is false. Execution continues on line 58
   66 |     while (cell != NULL) {
      |     ^
source/algos/simon.c:58:15: note: Assuming 'i' is < 'm'
   58 |   for (i = 1; i < m; ++i) {
      |               ^~~~~
source/algos/simon.c:58:3: note: Loop condition is true.  Entering loop body
   58 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/simon.c:60:13: note: '?' condition is true
   60 |     cell = (ell == -1 ? NULL : L[k]);
      |             ^
source/algos/simon.c:62:9: note: Assuming the condition is true
   62 |     if (x[i] == x[k + 1])
      |         ^~~~~~~~~~~~~~~~
source/algos/simon.c:62:5: note: Taking true branch
   62 |     if (x[i] == x[k + 1])
      |     ^
source/algos/simon.c:66:5: note: Loop condition is false. Execution continues on line 58
   66 |     while (cell != NULL) {
      |     ^
source/algos/simon.c:58:15: note: Assuming 'i' is >= 'm'
   58 |   for (i = 1; i < m; ++i) {
      |               ^~~~~
source/algos/simon.c:58:3: note: Loop condition is false. Execution continues on line 75
   58 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/simon.c:84:9: note: Returned allocated memory via 3rd parameter
   84 |   ell = preSimon(x, m, L);
      |         ^~~~~~~~~~~~~~~~~
source/algos/simon.c:85:3: note: Assuming 'pre_time' is null
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/simon.c:85:3: note: Taking false branch
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/simon.c:90:27: note: Assuming 'j' is >= 'n'
   90 |   for (state = -1, j = 0; j < n; ++j) {
      |                           ^~~~~
source/algos/simon.c:90:3: note: Loop condition is false. Execution continues on line 97
   90 |   for (state = -1, j = 0; j < n; ++j) {
      |   ^
source/algos/simon.c:97:3: note: Potential memory leak
   97 |   END_SEARCHING
      |   ^
source/algos/include/main.h:53:5: note: expanded from macro 'END_SEARCHING'
   53 |     timer_stop(_timer);                                                        \
      |     ^
source/algos/skip.c:29:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   29 |   memset(z, 0, SIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip.c:29:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   29 |   memset(z, 0, SIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip.c:30:24: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   30 |   for (i = 0; i < m; ++i) {
      |                        ^
source/algos/skip.c:30:15: note: Assuming 'i' is < 'm'
   30 |   for (i = 0; i < m; ++i) {
      |               ^~~~~
source/algos/skip.c:30:3: note: Loop condition is true.  Entering loop body
   30 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/skip.c:31:17: note: Memory is allocated
   31 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip.c:32:9: note: Assuming 'ptr' is not equal to NULL
   32 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip.c:32:5: note: Taking false branch
   32 |     if (ptr == NULL)
      |     ^
source/algos/skip.c:30:15: note: Assuming 'i' is < 'm'
   30 |   for (i = 0; i < m; ++i) {
      |               ^~~~~
source/algos/skip.c:30:3: note: Loop condition is true.  Entering loop body
   30 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/skip.c:32:9: note: Assuming 'ptr' is not equal to NULL
   32 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip.c:32:5: note: Taking false branch
   32 |     if (ptr == NULL)
      |     ^
source/algos/skip.c:30:24: note: Potential memory leak
   30 |   for (i = 0; i < m; ++i) {
      |                        ^
source/algos/skip2.c:35:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip2.c:35:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip2.c:36:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip2.c:31:7: note: Assuming 'm' is >= Q
   31 |   if (m < Q)
      |       ^~~~~
source/algos/skip2.c:31:3: note: Taking false branch
   31 |   if (m < Q)
      |   ^
source/algos/skip2.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip2.c:37:17: note: Memory is allocated
   37 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip2.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip2.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip2.c:36:15: note: Assuming the condition is true
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip2.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip2.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip2.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip2.c:36:32: note: Potential memory leak
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip3.c:35:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip3.c:35:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip3.c:36:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip3.c:31:7: note: Assuming 'm' is >= Q
   31 |   if (m < Q)
      |       ^~~~~
source/algos/skip3.c:31:3: note: Taking false branch
   31 |   if (m < Q)
      |   ^
source/algos/skip3.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip3.c:37:17: note: Memory is allocated
   37 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip3.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip3.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip3.c:36:15: note: Assuming the condition is true
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip3.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip3.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip3.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip3.c:36:32: note: Potential memory leak
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip4.c:35:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip4.c:35:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   35 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip4.c:36:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip4.c:31:7: note: Assuming 'm' is >= Q
   31 |   if (m < Q)
      |       ^~~~~
source/algos/skip4.c:31:3: note: Taking false branch
   31 |   if (m < Q)
      |   ^
source/algos/skip4.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip4.c:37:17: note: Memory is allocated
   37 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip4.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip4.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip4.c:36:15: note: Assuming the condition is true
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip4.c:36:3: note: Loop condition is true.  Entering loop body
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip4.c:38:9: note: Assuming 'ptr' is not equal to NULL
   38 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip4.c:38:5: note: Taking false branch
   38 |     if (ptr == NULL)
      |     ^
source/algos/skip4.c:36:32: note: Potential memory leak
   36 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip5.c:36:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   36 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip5.c:36:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   36 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip5.c:37:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   37 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip5.c:32:7: note: Assuming 'm' is >= Q
   32 |   if (m < Q)
      |       ^~~~~
source/algos/skip5.c:32:3: note: Taking false branch
   32 |   if (m < Q)
      |   ^
source/algos/skip5.c:37:3: note: Loop condition is true.  Entering loop body
   37 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip5.c:38:17: note: Memory is allocated
   38 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip5.c:39:9: note: Assuming 'ptr' is not equal to NULL
   39 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip5.c:39:5: note: Taking false branch
   39 |     if (ptr == NULL)
      |     ^
source/algos/skip5.c:37:15: note: Assuming the condition is true
   37 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip5.c:37:3: note: Loop condition is true.  Entering loop body
   37 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip5.c:39:9: note: Assuming 'ptr' is not equal to NULL
   39 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip5.c:39:5: note: Taking false branch
   39 |     if (ptr == NULL)
      |     ^
source/algos/skip5.c:37:32: note: Potential memory leak
   37 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip6.c:37:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip6.c:37:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip6.c:38:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip6.c:33:7: note: Assuming 'm' is >= Q
   33 |   if (m < Q)
      |       ^~~~~
source/algos/skip6.c:33:3: note: Taking false branch
   33 |   if (m < Q)
      |   ^
source/algos/skip6.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip6.c:39:17: note: Memory is allocated
   39 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip6.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip6.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip6.c:38:15: note: Assuming the condition is true
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip6.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip6.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip6.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip6.c:38:32: note: Potential memory leak
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip7.c:37:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip7.c:37:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip7.c:38:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip7.c:33:7: note: Assuming 'm' is >= Q
   33 |   if (m < Q)
      |       ^~~~~
source/algos/skip7.c:33:3: note: Taking false branch
   33 |   if (m < Q)
      |   ^
source/algos/skip7.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip7.c:39:17: note: Memory is allocated
   39 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip7.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip7.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip7.c:38:15: note: Assuming the condition is true
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip7.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip7.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip7.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip7.c:38:32: note: Potential memory leak
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip8.c:37:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip8.c:37:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   37 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip8.c:38:32: warning: Potential memory leak [clang-analyzer-unix.Malloc]
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/skip8.c:33:7: note: Assuming 'm' is >= Q
   33 |   if (m < Q)
      |       ^~~~~
source/algos/skip8.c:33:3: note: Taking false branch
   33 |   if (m < Q)
      |   ^
source/algos/skip8.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip8.c:39:17: note: Memory is allocated
   39 |     ptr = (List)malloc(sizeof(struct _cell));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/skip8.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip8.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip8.c:38:15: note: Assuming the condition is true
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |               ^~~~~~~~~~~~~
source/algos/skip8.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |   ^
source/algos/skip8.c:40:9: note: Assuming 'ptr' is not equal to NULL
   40 |     if (ptr == NULL)
      |         ^~~~~~~~~~~
source/algos/skip8.c:40:5: note: Taking false branch
   40 |     if (ptr == NULL)
      |     ^
source/algos/skip8.c:38:32: note: Potential memory leak
   38 |   for (i = 0; i < m - Q + 1; ++i) {
      |                                ^
source/algos/ssef.c:45:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   45 |   memset(flist, 0, sizeof(LIST *) * 65536);
      |   ^~~~~~
source/algos/ssef.c:45:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   45 |   memset(flist, 0, sizeof(LIST *) * 65536);
      |   ^~~~~~
source/algos/ssef.c:64:3: warning: Value stored to 'count' is never read [clang-analyzer-deadcode.DeadStores]
   64 |   count = 15;
      |   ^       ~~
source/algos/ssef.c:64:3: note: Value stored to 'count' is never read
   64 |   count = 15;
      |   ^       ~~
source/algos/ssm.c:49:16: warning: The right operand of '>=' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   49 |       if (rept >= Shift[i - 1])
      |                ^
source/algos/ssm.c:73:3: note: Calling 'PreProc'
   73 |   PreProc(Dis, Sht, x, m);
      |   ^~~~~~~~~~~~~~~~~~~~~~~
source/algos/ssm.c:35:15: note: Assuming 'i' is >= 'm'
   35 |   for (i = 1; i < m; i++) {
      |               ^~~~~
source/algos/ssm.c:35:3: note: Loop condition is false. Execution continues on line 46
   35 |   for (i = 1; i < m; i++) {
      |   ^
source/algos/ssm.c:47:19: note: Assuming 'i' is > 0
   47 |   for (i = m - 1; i > 0; i--) {
      |                   ^~~~~
source/algos/ssm.c:47:3: note: Loop condition is true.  Entering loop body
   47 |   for (i = m - 1; i > 0; i--) {
      |   ^
source/algos/ssm.c:48:9: note: Assuming the condition is true
   48 |     if (x[i] != x[i - 1]) {
      |         ^~~~~~~~~~~~~~~~
source/algos/ssm.c:48:5: note: Taking true branch
   48 |     if (x[i] != x[i - 1]) {
      |     ^
source/algos/ssm.c:49:16: note: The right operand of '>=' is a garbage value due to array index out of bounds
   49 |       if (rept >= Shift[i - 1])
      |                ^  ~~~~~~~~~~~~
source/algos/ssm.c:82:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   82 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/ssm.c:82:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   82 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/ssm.c:97:11: warning: The right operand of '+' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   97 |     j = j + Sht[q];
      |           ^ ~~~~~~
source/algos/ssm.c:73:3: note: Calling 'PreProc'
   73 |   PreProc(Dis, Sht, x, m);
      |   ^~~~~~~~~~~~~~~~~~~~~~~
source/algos/ssm.c:35:15: note: Assuming 'i' is >= 'm'
   35 |   for (i = 1; i < m; i++) {
      |               ^~~~~
source/algos/ssm.c:35:3: note: Loop condition is false. Execution continues on line 46
   35 |   for (i = 1; i < m; i++) {
      |   ^
source/algos/ssm.c:47:19: note: Assuming 'i' is <= 0
   47 |   for (i = m - 1; i > 0; i--) {
      |                   ^~~~~
source/algos/ssm.c:47:3: note: Loop condition is false. Execution continues on line 58
   47 |   for (i = m - 1; i > 0; i--) {
      |   ^
source/algos/ssm.c:58:15: note: Assuming 'i' is < 'm'
   58 |   for (i = 0; i < m; i++)
      |               ^~~~~
source/algos/ssm.c:58:3: note: Loop condition is true.  Entering loop body
   58 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ssm.c:59:9: note: Assuming the condition is false
   59 |     if (Shift[i] < Dist[m])
      |         ^~~~~~~~~~~~~~~~~~
source/algos/ssm.c:59:5: note: Taking false branch
   59 |     if (Shift[i] < Dist[m])
      |     ^
source/algos/ssm.c:58:3: note: Loop condition is false. Execution continues on line 58
   58 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ssm.c:73:3: note: Returning from 'PreProc'
   73 |   PreProc(Dis, Sht, x, m);
      |   ^~~~~~~~~~~~~~~~~~~~~~~
source/algos/ssm.c:74:3: note: Assuming 'pre_time' is null
   74 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/ssm.c:74:3: note: Taking false branch
   74 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/ssm.c:83:10: note: Assuming 'j' is < 'n'
   83 |   while (j < n) {
      |          ^~~~~
source/algos/ssm.c:83:3: note: Loop condition is true.  Entering loop body
   83 |   while (j < n) {
      |   ^
source/algos/ssm.c:84:5: note: Loop condition is true.  Entering loop body
   84 |     while (y[j + jMax] != xMax)
      |     ^
source/algos/ssm.c:84:5: note: Loop condition is false. Execution continues on line 87
source/algos/ssm.c:89:13: note: 'q' is >= 0
   89 |     while ((q >= 0) && (x[q] == y[q + Pos]))
      |             ^
source/algos/ssm.c:89:12: note: Left side of '&&' is true
   89 |     while ((q >= 0) && (x[q] == y[q + Pos]))
      |            ^
source/algos/ssm.c:89:5: note: Loop condition is true.  Entering loop body
   89 |     while ((q >= 0) && (x[q] == y[q + Pos]))
      |     ^
source/algos/ssm.c:90:7: note: The value -1 is assigned to 'q'
   90 |       q--;
      |       ^~~
source/algos/ssm.c:89:13: note: 'q' is < 0
   89 |     while ((q >= 0) && (x[q] == y[q + Pos]))
      |             ^
source/algos/ssm.c:89:21: note: Left side of '&&' is false
   89 |     while ((q >= 0) && (x[q] == y[q + Pos]))
      |                     ^
source/algos/ssm.c:92:10: note: 'q' is < 0
   92 |     if ((q < 0) && (j < n)) {
      |          ^
source/algos/ssm.c:92:9: note: Left side of '&&' is true
   92 |     if ((q < 0) && (j < n)) {
      |         ^
source/algos/ssm.c:92:21: note: Assuming 'j' is >= 'n'
   92 |     if ((q < 0) && (j < n)) {
      |                     ^~~~~
source/algos/ssm.c:92:5: note: Taking false branch
   92 |     if ((q < 0) && (j < n)) {
      |     ^
source/algos/ssm.c:97:11: note: The right operand of '+' is a garbage value due to array index out of bounds
   97 |     j = j + Sht[q];
      |           ^ ~~~~~~
source/algos/tbm.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/tbm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/tbm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/tbm.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/tbm.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/tbm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/tbm.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/tbm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/tbm.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/tbm.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/tbm.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/tbm.c:92:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   92 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/tbm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/tbm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/tbm.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/tbm.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/tbm.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/tbm.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/tbm.c:74:3: note: Returning from 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:76:3: note: Assuming 'pre_time' is null
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/tbm.c:76:3: note: Taking false branch
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/tbm.c:83:10: note: Assuming the condition is true
   83 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/tbm.c:83:3: note: Loop condition is true.  Entering loop body
   83 |   while (j <= n - m) {
      |   ^
source/algos/tbm.c:85:12: note: 'i' is < 0
   85 |     while (i >= 0 && x[i] == y[i + j]) {
      |            ^
source/algos/tbm.c:85:19: note: Left side of '&&' is false
   85 |     while (i >= 0 && x[i] == y[i + j]) {
      |                   ^
source/algos/tbm.c:90:9: note: 'i' is < 0
   90 |     if (i < 0) {
      |         ^
source/algos/tbm.c:90:5: note: Taking true branch
   90 |     if (i < 0) {
      |     ^
source/algos/tbm.c:92:13: note: Assigned value is garbage or undefined
   92 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/trf.c:71:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   71 |       memcpy(ttrans + r * SIGMA, ttrans + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:71:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   71 |       memcpy(ttrans + r * SIGMA, ttrans + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:72:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   72 |       memcpy(tshift + r * SIGMA, tshift + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:72:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   72 |       memcpy(tshift + r * SIGMA, tshift + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:111:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  111 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/trf.c:111:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  111 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/trf.c:117:3: warning: Value stored to 'i' is never read [clang-analyzer-deadcode.DeadStores]
  117 |   i = 0;
      |   ^   ~
source/algos/trf.c:117:3: note: Value stored to 'i' is never read
  117 |   i = 0;
      |   ^   ~
source/algos/tsa-q2.c:28:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   28 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa-q2.c:28:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   28 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa.c:21:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   21 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa.c:21:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   21 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tso5.c:22:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   22 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tso5.c:22:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   22 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tunbm.c:47:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   47 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunbm.c:47:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   47 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunedbm.c:43:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   43 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunedbm.c:43:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   43 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/ww.c:33:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   33 |   memset(ttransSMA, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:33:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   33 |   memset(ttransSMA, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:54:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   54 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:54:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   54 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:65:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   65 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:65:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   65 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/zt.c:58:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   58 |         if (bmGs[j] == m)
      |                     ^
source/algos/zt.c:82:3: note: Calling 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:52:15: note: Assuming 'i' is >= 'm'
   52 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/zt.c:52:3: note: Loop condition is false. Execution continues on line 54
   52 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/zt.c:54:3: note: The value 0 is assigned to 'j'
   54 |   j = 0;
      |   ^~~~~
source/algos/zt.c:55:19: note: Assuming 'i' is >= 0
   55 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/zt.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:56:9: note: Assuming the condition is false
   56 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/zt.c:56:5: note: Taking false branch
   56 |     if (suff[i] == i + 1)
      |     ^
source/algos/zt.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:56:9: note: Assuming the condition is true
   56 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/zt.c:56:5: note: Taking true branch
   56 |     if (suff[i] == i + 1)
      |     ^
source/algos/zt.c:57:7: note: Loop condition is true.  Entering loop body
   57 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/zt.c:58:21: note: The left operand of '==' is a garbage value
   58 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/zt.c:97:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   97 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/zt.c:82:3: note: Calling 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:52:15: note: Assuming 'i' is >= 'm'
   52 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/zt.c:52:3: note: Loop condition is false. Execution continues on line 54
   52 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/zt.c:55:19: note: Assuming 'i' is < 0
   55 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/zt.c:55:3: note: Loop condition is false. Execution continues on line 60
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:60:15: note: Assuming the condition is false
   60 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/zt.c:60:3: note: Loop condition is false. Execution continues on line 60
   60 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/zt.c:62:1: note: Returning without writing to '*bmGs'
   62 | }
      | ^
source/algos/zt.c:82:3: note: Returning from 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:83:15: note: 'i' is >= 'm'
   83 |   for (i = 0; i < m; i++)
      |               ^
source/algos/zt.c:83:3: note: Loop condition is false. Execution continues on line 85
   83 |   for (i = 0; i < m; i++)
      |   ^
source/algos/zt.c:85:3: note: Assuming 'pre_time' is null
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/zt.c:85:3: note: Taking false branch
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/zt.c:91:10: note: Assuming the condition is true
   91 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/zt.c:91:3: note: Loop condition is true.  Entering loop body
   91 |   while (j <= n - m) {
      |   ^
source/algos/zt.c:93:12: note: 'i' is < 0
   93 |     while (i >= 0 && x[i] == y[i + j])
      |            ^
source/algos/zt.c:93:19: note: Left side of '&&' is false
   93 |     while (i >= 0 && x[i] == y[i + j])
      |                   ^
source/algos/zt.c:95:9: note: 'i' is < 0
   95 |     if (i < 0) {
      |         ^
source/algos/zt.c:95:5: note: Taking true branch
   95 |     if (i < 0) {
      |     ^
source/algos/zt.c:97:9: note: Assigned value is garbage or undefined
   97 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/compilesm.c:38:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   38 |   strcat(options, " -Wall");
      |   ^~~~~~
source/compilesm.c:38:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   38 |   strcat(options, " -Wall");
      |   ^~~~~~
source/compilesm.c:41:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   41 |   strcat(options, " -march=native -mtune=native");
      |   ^~~~~~
source/compilesm.c:41:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   41 |   strcat(options, " -march=native -mtune=native");
      |   ^~~~~~
source/compilesm.c:60:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   60 |   strcat(options, " -lm");
      |   ^~~~~~
source/compilesm.c:60:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   60 |   strcat(options, " -lm");
      |   ^~~~~~
source/compilesm.c:70:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   70 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:70:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   70 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:73:7: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   73 |       snprintf(command, sizeof(command)-1, "%s%s", destdir, filename);
      |       ^~~~~~~~
source/compilesm.c:73:7: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
   73 |       snprintf(command, sizeof(command)-1, "%s%s", destdir, filename);
      |       ^~~~~~~~
source/compilesm.c:77:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
   77 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:67:3: note: Value assigned to 'd'
   67 |   d = opendir(destdir);
      |   ^~~~~~~~~~~~~~~~~~~~
source/compilesm.c:68:7: note: Assuming 'd' is null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking false branch
   68 |   if (d) {
      |   ^
source/compilesm.c:77:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
   77 |   closedir(d);
      |   ^        ~
source/compilesm.c:84:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   84 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:84:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   84 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:91:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
   91 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:80:3: note: Value assigned to 'd'
   80 |   d = opendir("./source/algos");
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:82:7: note: Assuming 'd' is null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking false branch
   82 |   if (d) {
      |   ^
source/compilesm.c:91:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
   91 |   closedir(d);
      |   ^        ~
source/compilesm.c:99:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   99 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:99:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   99 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:114:9: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  114 |         snprintf(command, sizeof(command)-1, "%s%s.c%s -o %s%s", gcc,
      |         ^~~~~~~~
source/compilesm.c:114:9: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  114 |         snprintf(command, sizeof(command)-1, "%s%s.c%s -o %s%s", gcc,
      |         ^~~~~~~~
source/compilesm.c:125:54: warning: Division by zero [clang-analyzer-core.DivideZero]
  125 |         printf("\b\b\b\b\b\b[%.3d%%]", current * 100 / n_algo);
      |                                        ~~~~~~~~~~~~~~^~~~~~~~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:81:3: note: 'n_algo' initialized to 0
   81 |   int n_algo = 0;
      |   ^~~~~~~~~~
source/compilesm.c:82:7: note: Assuming 'd' is non-null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking true branch
   82 |   if (d) {
      |   ^
source/compilesm.c:83:12: note: Assuming the condition is false
   83 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:83:5: note: Loop condition is false. Execution continues on line 91
   83 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:97:7: note: Assuming 'd' is non-null
   97 |   if (d) {
      |       ^
source/compilesm.c:97:3: note: Taking true branch
   97 |   if (d) {
      |   ^
source/compilesm.c:98:12: note: Assuming the condition is true
   98 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:98:5: note: Loop condition is true.  Entering loop body
   98 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:101:11: note: Assuming 'len' is > 2
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.') {
      |           ^~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
source/compilesm.c:101:22: note: Assuming the condition is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.') {
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.') {
      |           ^
source/compilesm.c:101:50: note: Assuming the condition is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.') {
      |                                                  ^~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:101:7: note: Taking true branch
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.') {
      |       ^
source/compilesm.c:116:13: note: 'doTest' is 0
  116 |         if (doTest)
      |             ^~~~~~
source/compilesm.c:116:9: note: Taking false branch
  116 |         if (doTest)
      |         ^
source/compilesm.c:120:21: note: Assuming the condition is false
  120 |         for (i = 0; i < 15 - strlen(filename); i++)
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:120:9: note: Loop condition is false. Execution continues on line 122
  120 |         for (i = 0; i < 15 - strlen(filename); i++)
      |         ^
source/compilesm.c:125:54: note: Division by zero
  125 |         printf("\b\b\b\b\b\b[%.3d%%]", current * 100 / n_algo);
      |                                        ~~~~~~~~~~~~~~^~~~~~~~
source/compilesm.c:137:11: warning: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  137 |           strncpy(binary, destdir, sizeof(binary) - 1);
      |           ^~~~~~~
source/compilesm.c:137:11: note: Call to function 'strncpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncpy_s' in case of C11
  137 |           strncpy(binary, destdir, sizeof(binary) - 1);
      |           ^~~~~~~
source/compilesm.c:138:11: warning: Call to function 'strncat' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncat_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  138 |           strncat(binary, filename, sizeof(binary) - 1);
      |           ^~~~~~~
source/compilesm.c:138:11: note: Call to function 'strncat' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'strncat_s' in case of C11
  138 |           strncat(binary, filename, sizeof(binary) - 1);
      |           ^~~~~~~
source/compilesm.c:138:37: warning: Potential buffer overflow. Replace with 'sizeof(binary) - strlen(binary) - 1' or use a safer 'strlcat' API [clang-analyzer-unix.cstring.BadSizeArg]
  138 |           strncat(binary, filename, sizeof(binary) - 1);
      |                                     ^~~~~~~~~~~~~~~~~~
source/compilesm.c:138:37: note: Potential buffer overflow. Replace with 'sizeof(binary) - strlen(binary) - 1' or use a safer 'strlcat' API
  138 |           strncat(binary, filename, sizeof(binary) - 1);
      |                                     ^~~~~~~~~~~~~~~~~~
source/compilesm.c:146:15: warning: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  146 |               snprintf(command, sizeof(command)-1, "./test %s -nv", filename);
      |               ^~~~~~~~
source/compilesm.c:146:15: note: Call to function 'snprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'snprintf_s' in case of C11
  146 |               snprintf(command, sizeof(command)-1, "./test %s -nv", filename);
      |               ^~~~~~~~
source/compilesm.c:171:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
  171 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:82:7: note: Assuming 'd' is non-null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking true branch
   82 |   if (d) {
      |   ^
source/compilesm.c:83:12: note: Assuming the condition is false
   83 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:83:5: note: Loop condition is false. Execution continues on line 91
   83 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:96:3: note: Value assigned to 'd'
   96 |   d = opendir("./source/algos");
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:97:7: note: Assuming 'd' is null
   97 |   if (d) {
      |       ^
source/compilesm.c:97:3: note: Taking false branch
   97 |   if (d) {
      |   ^
source/compilesm.c:171:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
  171 |   closedir(d);
      |   ^        ~
source/selectAlgo.c:88:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   88 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:88:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   88 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:89:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   89 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:89:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   89 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:119:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  119 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:119:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  119 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:120:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  120 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:120:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  120 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:145:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  145 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:145:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  145 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:147:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  147 |       strcat(path, algo);
      |       ^~~~~~
source/selectAlgo.c:147:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  147 |       strcat(path, algo);
      |       ^~~~~~
source/selectAlgo.c:161:11: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  161 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:161:11: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  161 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:191:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  191 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:191:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  191 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:193:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  193 |       strcat(path, filename);
      |       ^~~~~~
source/selectAlgo.c:193:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  193 |       strcat(path, filename);
      |       ^~~~~~
source/selectAlgo.c:207:11: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  207 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:207:11: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  207 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/smart.c:118:3: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  118 |   sprintf(code, "EXP%d", t);
      |   ^~~~~~~
source/smart.c:118:3: note: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  118 |   sprintf(code, "EXP%d", t);
      |   ^~~~~~~
source/smart.c:125:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  125 |   strcpy(indexfilename, path);
      |   ^~~~~~
source/smart.c:125:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  125 |   strcpy(indexfilename, path);
      |   ^~~~~~
source/smart.c:126:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  126 |   strcat(indexfilename, "/index.txt");
      |   ^~~~~~
source/smart.c:126:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  126 |   strcat(indexfilename, "/index.txt");
      |   ^~~~~~
source/smart.c:133:9: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  133 |         strcpy(filename, path);
      |         ^~~~~~
source/smart.c:133:9: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  133 |         strcpy(filename, path);
      |         ^~~~~~
source/smart.c:180:3: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  180 |   sprintf(command, "./%s/%s shared %d %d %d %d %d %d %d", BINDIR,
      |   ^~~~~~~
source/smart.c:180:3: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  180 |   sprintf(command, "./%s/%s shared %d %d %d %d %d %d %d", BINDIR,
      |   ^~~~~~~
source/smart.c:195:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  195 |       strcpy((char *)setP[i], (char *)simplePattern);
      |       ^~~~~~
source/smart.c:195:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  195 |       strcpy((char *)setP[i], (char *)simplePattern);
      |       ^~~~~~
source/smart.c:244:5: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  244 |     sprintf(logfile, "results/%s", code);
      |     ^~~~~~~
source/smart.c:244:5: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  244 |     sprintf(logfile, "results/%s", code);
      |     ^~~~~~~
source/smart.c:250:5: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  250 |     strcat(logfile, "/errorlog.txt");
      |     ^~~~~~
source/smart.c:250:5: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  250 |     strcat(logfile, "/errorlog.txt");
      |     ^~~~~~
source/smart.c:383:11: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  383 |           sprintf(data, "\t - [%d/%d] %s ", current_running, num_running,
      |           ^~~~~~~
source/smart.c:383:11: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  383 |           sprintf(data, "\t - [%d/%d] %s ", current_running, num_running,
      |           ^~~~~~~
source/smart.c:442:17: warning: variable 'nchar' set but not used [clang-diagnostic-unused-but-set-variable]
  442 |             int nchar = 15;
      |                 ^
source/smart.c:446:15: warning: Value stored to 'nchar' is never read [clang-analyzer-deadcode.DeadStores]
  446 |               nchar += 15;
      |               ^        ~~
source/smart.c:446:15: note: Value stored to 'nchar' is never read
  446 |               nchar += 15;
      |               ^        ~~
source/smart.c:450:15: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  450 |               sprintf(data, "\t\%.2f + \%.2f ms", PRE_TIME[algo][il],
      |               ^~~~~~~
source/smart.c:450:15: note: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  450 |               sprintf(data, "\t\%.2f + \%.2f ms", PRE_TIME[algo][il],
      |               ^~~~~~~
source/smart.c:453:15: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  453 |               sprintf(data, "\t\%.2f ms", TIME[algo][il]);
      |               ^~~~~~~
source/smart.c:453:15: note: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  453 |               sprintf(data, "\t\%.2f ms", TIME[algo][il]);
      |               ^~~~~~~
source/smart.c:458:15: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  458 |               sprintf(data, " [%.2f, %.2f]", BEST[algo][il], WORST[algo][il]);
      |               ^~~~~~~
source/smart.c:458:15: note: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  458 |               sprintf(data, " [%.2f, %.2f]", BEST[algo][il], WORST[algo][il]);
      |               ^~~~~~~
source/smart.c:464:15: warning: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  464 |               sprintf(data, " std %.2f", STD[algo][il]);
      |               ^~~~~~~
source/smart.c:464:15: note: Call to function 'sprintf' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  464 |               sprintf(data, " std %.2f", STD[algo][il]);
      |               ^~~~~~~
source/smart.c:514:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  514 |   strcpy(filename, "");
      |   ^~~~~~
source/smart.c:514:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  514 |   strcpy(filename, "");
      |   ^~~~~~
source/smart.c:562:9: warning: Potential leak of memory pointed to by 'filename' [clang-analyzer-unix.Malloc]
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:513:28: note: Memory is allocated
  513 |   char *filename = (char *)malloc(sizeof(char) * (100));
      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:543:7: note: Assuming 'argc' is not equal to 1
  543 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:543:3: note: Taking false branch
  543 |   if (argc == 1) {
      |   ^
source/smart.c:550:7: note: Assuming the condition is false
  550 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:550:3: note: Taking false branch
  550 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:558:10: note: 'par' is < 'argc'
  558 |   while (par < argc) {
      |          ^~~
source/smart.c:558:3: note: Loop condition is true.  Entering loop body
  558 |   while (par < argc) {
      |   ^
source/smart.c:559:9: note: 'par' is < 'argc'
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:559:9: note: Left side of '&&' is true
source/smart.c:559:5: note: Taking true branch
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:561:11: note: Assuming 'par' is >= 'argc'
  561 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:561:7: note: Taking true branch
  561 |       if (par >= argc) {
      |       ^
source/smart.c:562:9: note: Potential leak of memory pointed to by 'filename'
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:562:9: warning: Potential leak of memory pointed to by 'simplePattern' [clang-analyzer-unix.Malloc]
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:530:51: note: Memory is allocated
  530 |   unsigned char *simplePattern = (unsigned char *)malloc(
      |                                                   ^~~~~~~
  531 |       sizeof(unsigned char) * (100)); // used for the simple run of SMART
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:543:7: note: Assuming 'argc' is not equal to 1
  543 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:543:3: note: Taking false branch
  543 |   if (argc == 1) {
      |   ^
source/smart.c:550:7: note: Assuming the condition is false
  550 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:550:3: note: Taking false branch
  550 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:558:10: note: 'par' is < 'argc'
  558 |   while (par < argc) {
      |          ^~~
source/smart.c:558:3: note: Loop condition is true.  Entering loop body
  558 |   while (par < argc) {
      |   ^
source/smart.c:559:9: note: 'par' is < 'argc'
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:559:9: note: Left side of '&&' is true
source/smart.c:559:5: note: Taking true branch
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:561:11: note: Assuming 'par' is >= 'argc'
  561 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:561:7: note: Taking true branch
  561 |       if (par >= argc) {
      |       ^
source/smart.c:562:9: note: Potential leak of memory pointed to by 'simplePattern'
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:562:9: warning: Potential leak of memory pointed to by 'simpleText' [clang-analyzer-unix.Malloc]
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:532:48: note: Memory is allocated
  532 |   unsigned char *simpleText = (unsigned char *)malloc(
      |                                                ^~~~~~~
  533 |       sizeof(unsigned char) * (1000)); // used for the simple run of SMART
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:543:7: note: Assuming 'argc' is not equal to 1
  543 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:543:3: note: Taking false branch
  543 |   if (argc == 1) {
      |   ^
source/smart.c:550:7: note: Assuming the condition is false
  550 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:550:3: note: Taking false branch
  550 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:558:10: note: 'par' is < 'argc'
  558 |   while (par < argc) {
      |          ^~~
source/smart.c:558:3: note: Loop condition is true.  Entering loop body
  558 |   while (par < argc) {
      |   ^
source/smart.c:559:9: note: 'par' is < 'argc'
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:559:9: note: Left side of '&&' is true
source/smart.c:559:5: note: Taking true branch
  559 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:561:11: note: Assuming 'par' is >= 'argc'
  561 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:561:7: note: Taking true branch
  561 |       if (par >= argc) {
      |       ^
source/smart.c:562:9: note: Potential leak of memory pointed to by 'simpleText'
  562 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:565:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  565 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:565:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  565 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:578:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  578 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:578:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  578 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:592:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  592 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:592:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  592 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:605:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  605 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:605:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  605 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:606:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  606 |       strcat(filename, parameter);
      |       ^~~~~~
source/smart.c:606:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  606 |       strcat(filename, parameter);
      |       ^~~~~~
source/smart.c:614:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  614 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:614:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  614 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:626:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  626 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:626:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  626 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:641:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  641 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:641:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  641 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:642:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  642 |       strcpy((char *)simplePattern, parameter);
      |       ^~~~~~
source/smart.c:642:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  642 |       strcpy((char *)simplePattern, parameter);
      |       ^~~~~~
source/smart.c:651:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  651 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:651:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  651 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:652:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  652 |       strcpy((char *)simpleText, parameter);
      |       ^~~~~~
source/smart.c:652:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  652 |       strcpy((char *)simpleText, parameter);
      |       ^~~~~~
source/smart.c:751:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  751 |     strcpy((char *)T, (char *)simpleText);
      |     ^~~~~~
source/smart.c:751:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  751 |     strcpy((char *)T, (char *)simpleText);
      |     ^~~~~~
source/smart.c:792:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  792 |       strcat(fullpath, list_of_filenames[k]);
      |       ^~~~~~
source/smart.c:792:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  792 |       strcat(fullpath, list_of_filenames[k]);
      |       ^~~~~~
source/smart.c:831:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  831 |       strcat(fullpath, SETTING_BUFFER[sett]);
      |       ^~~~~~
source/smart.c:831:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  831 |       strcat(fullpath, SETTING_BUFFER[sett]);
      |       ^~~~~~
source/test.c:95:3: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   95 |   sprintf(command, "./%s/%s shared %d %d %d %d %d %d %d", BINDIR, algoname,
      |   ^~~~~~~
source/test.c:95:3: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
   95 |   sprintf(command, "./%s/%s shared %d %d %d %d %d %d %d", BINDIR, algoname,
      |   ^~~~~~~
source/test.c:161:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  161 |   strcpy(algoname, argv[1]);
      |   ^~~~~~
source/test.c:161:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  161 |   strcpy(algoname, argv[1]);
      |   ^~~~~~
source/test.c:164:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  164 |     strcpy(parameter, argv[2]);
      |     ^~~~~~
source/test.c:164:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  164 |     strcpy(parameter, argv[2]);
      |     ^~~~~~
source/test.c:166:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  166 |   strcat(filename, algoname);
      |   ^~~~~~
source/test.c:166:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  166 |   strcat(filename, algoname);
      |   ^~~~~~
source/test.c:323:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  323 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:323:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  323 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:324:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  324 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:324:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  324 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:332:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  332 |     strcpy((char *)P, "aa");
      |     ^~~~~~
source/test.c:332:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  332 |     strcpy((char *)P, "aa");
      |     ^~~~~~
source/test.c:333:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  333 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:333:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  333 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:340:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  340 |   strcpy((char *)P, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:340:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  340 |   strcpy((char *)P, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:341:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  341 |   strcpy((char *)T, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:341:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  341 |   strcpy((char *)T, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:348:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  348 |     strcpy((char *)P, "b");
      |     ^~~~~~
source/test.c:348:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  348 |     strcpy((char *)P, "b");
      |     ^~~~~~
source/test.c:349:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  349 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:349:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  349 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:357:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  357 |     strcpy((char *)P, "ab");
      |     ^~~~~~
source/test.c:357:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  357 |     strcpy((char *)P, "ab");
      |     ^~~~~~
source/test.c:358:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  358 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:358:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  358 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:366:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  366 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:366:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  366 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:367:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  367 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:367:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  367 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:375:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  375 |     strcpy((char *)P, "aba");
      |     ^~~~~~
source/test.c:375:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  375 |     strcpy((char *)P, "aba");
      |     ^~~~~~
source/test.c:376:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  376 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:376:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  376 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:382:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  382 |     strcpy((char *)P, "abc");
      |     ^~~~~~
source/test.c:382:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  382 |     strcpy((char *)P, "abc");
      |     ^~~~~~
source/test.c:383:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  383 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:383:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  383 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:391:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  391 |     strcpy((char *)P, "ba");
      |     ^~~~~~
source/test.c:391:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  391 |     strcpy((char *)P, "ba");
      |     ^~~~~~
source/test.c:392:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  392 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:392:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  392 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:400:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  400 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:400:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  400 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:401:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  401 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:401:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  401 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:409:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  409 |     strcpy((char *)P, "bcdefg");
      |     ^~~~~~
source/test.c:409:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  409 |     strcpy((char *)P, "bcdefg");
      |     ^~~~~~
source/test.c:410:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  410 |     strcpy((char *)T, "bcdefghilm");
      |     ^~~~~~
source/test.c:410:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  410 |     strcpy((char *)T, "bcdefghilm");
      |     ^~~~~~
source/test.c:499:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  499 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:499:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  499 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:500:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  500 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:500:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  500 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:508:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  508 |     strcpy((char *)P, "bababb");
      |     ^~~~~~
source/test.c:508:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  508 |     strcpy((char *)P, "bababb");
      |     ^~~~~~
source/test.c:509:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  509 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:509:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  509 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/algos/ac.c:70:13: warning: The right operand of '-' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   70 |     j += (i - kmpNext[i]);
      |             ^ ~~~~~~~~~~
source/algos/ac.c:49:3: note: Calling 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/ac.c:32:10: note: Assuming 'i' is >= 'm'
   32 |   while (i < m) {
      |          ^~~~~
source/algos/ac.c:32:3: note: Loop condition is false. Execution continues on line 32
   32 |   while (i < m) {
      |   ^
source/algos/ac.c:49:3: note: Returning from 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/ac.c:50:8: note: The value 1 is assigned to 'ell'
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |        ^~~~~~~
source/algos/ac.c:50:17: note: 'ell' is >= 'm'
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |                 ^~~
source/algos/ac.c:50:25: note: Left side of '&&' is false
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |                         ^
source/algos/ac.c:52:7: note: 'ell' is not equal to 'm'
   52 |   if (ell == m)
      |       ^~~
source/algos/ac.c:52:3: note: Taking false branch
   52 |   if (ell == m)
      |   ^
source/algos/ac.c:54:3: note: Assuming 'pre_time' is null
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/ac.c:54:3: note: Taking false branch
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/ac.c:59:3: note: The value 1 is assigned to 'i'
   59 |   i = ell;
      |   ^~~~~~~
source/algos/ac.c:61:10: note: Assuming the condition is true
   61 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/ac.c:61:3: note: Loop condition is true.  Entering loop body
   61 |   while (j <= n - m) {
      |   ^
source/algos/ac.c:62:12: note: 'i' is >= 'm'
   62 |     while (i < m && x[i] == y[i + j])
      |            ^
source/algos/ac.c:62:18: note: Left side of '&&' is false
   62 |     while (i < m && x[i] == y[i + j])
      |                  ^
source/algos/ac.c:64:9: note: 'i' is >= 'm'
   64 |     if (i >= m) {
      |         ^
source/algos/ac.c:64:5: note: Taking true branch
   64 |     if (i >= m) {
      |     ^
source/algos/ac.c:65:14: note: 'k' is < 'ell'
   65 |       while (k < ell && x[k] == y[j + k])
      |              ^
source/algos/ac.c:65:14: note: Left side of '&&' is true
source/algos/ac.c:65:25: note: Assuming the condition is false
   65 |       while (k < ell && x[k] == y[j + k])
      |                         ^~~~~~~~~~~~~~~~
source/algos/ac.c:65:7: note: Loop condition is false. Execution continues on line 67
   65 |       while (k < ell && x[k] == y[j + k])
      |       ^
source/algos/ac.c:67:11: note: 'k' is < 'ell'
   67 |       if (k >= ell)
      |           ^
source/algos/ac.c:67:7: note: Taking false branch
   67 |       if (k >= ell)
      |       ^
source/algos/ac.c:70:13: note: The right operand of '-' is a garbage value
   70 |     j += (i - kmpNext[i]);
      |             ^ ~~~~~~~~~~
source/algos/ag.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/ag.c:75:3: note: Calling 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/ag.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/ag.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/ag.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/ag.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/ag.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/ag.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/ag.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/ag.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/ag.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/ag.c:77:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   77 |   memset(skip, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/ag.c:77:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   77 |   memset(skip, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/ag.c:111:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
  111 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/ag.c:75:3: note: Calling 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/ag.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/ag.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/ag.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/ag.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/ag.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/ag.c:75:3: note: Returning from 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:78:3: note: Assuming 'pre_time' is null
   78 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/ag.c:78:3: note: Taking false branch
   78 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/ag.c:84:10: note: Assuming the condition is true
   84 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/ag.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   while (j <= n - m) {
      |   ^
source/algos/ag.c:86:12: note: 'i' is < 0
   86 |     while (i >= 0) {
      |            ^
source/algos/ag.c:86:5: note: Loop condition is false. Execution continues on line 108
   86 |     while (i >= 0) {
      |     ^
source/algos/ag.c:108:9: note: 'i' is < 0
  108 |     if (i < 0) {
      |         ^
source/algos/ag.c:108:5: note: Taking true branch
  108 |     if (i < 0) {
      |     ^
source/algos/ag.c:111:13: note: Assigned value is garbage or undefined
  111 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/ag.c:117:5: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  117 |     memcpy(skip, skip + shift, (m - shift) * sizeof(int));
      |     ^~~~~~
source/algos/ag.c:117:5: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  117 |     memcpy(skip, skip + shift, (m - shift) * sizeof(int));
      |     ^~~~~~
source/algos/ag.c:118:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  118 |     memset(skip + m - shift, 0, shift * sizeof(int));
      |     ^~~~~~
source/algos/ag.c:118:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  118 |     memset(skip + m - shift, 0, shift * sizeof(int));
      |     ^~~~~~
source/algos/akc.c:102:24: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
  102 |   c = (unsigned char *)malloc(m * sizeof(char));
      |        ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:102:24: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
  102 |   c = (unsigned char *)malloc(m * sizeof(char));
      |        ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:104:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  104 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:104:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  104 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:160:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  160 |   memset(last, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:160:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  160 |   memset(last, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:179:24: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
  179 |   c = (unsigned char *)malloc(m * sizeof(char));
      |        ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:179:24: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
  179 |   c = (unsigned char *)malloc(m * sizeof(char));
      |        ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:190:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  190 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:190:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  190 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:201:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  201 |   memset(cptr, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:201:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  201 |   memset(cptr, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:215:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  215 |   memset(owner, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:215:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  215 |   memset(owner, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:276:24: warning: The left operand of '>' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
  276 |         while (next[i] > loc[i] - skip[ell]) {
      |                ~~~~~~~ ^
source/algos/akc.c:244:17: note: Storing uninitialized value
  244 |   next = (int *)malloc(m * sizeof(int));
      |                 ^~~~~~~~~~~~~~~~~~~~~~~
source/algos/akc.c:245:7: note: Assuming the condition is true
  245 |   if (skip[ell] < m) {
      |       ^~~~~~~~~~~~~
source/algos/akc.c:245:3: note: Taking true branch
  245 |   if (skip[ell] < m) {
      |   ^
source/algos/akc.c:250:9: note: Assuming the condition is false
  250 |     if (skip[ell] + k >= m)
      |         ^~~~~~~~~~~~~~~~~~
source/algos/akc.c:250:5: note: Taking false branch
  250 |     if (skip[ell] + k >= m)
      |     ^
source/algos/akc.c:254:9: note: Assuming the condition is false
  254 |     if (skip[ell] + k >= m)
      |         ^~~~~~~~~~~~~~~~~~
source/algos/akc.c:254:5: note: Taking false branch
  254 |     if (skip[ell] + k >= m)
      |     ^
source/algos/akc.c:257:5: note: Loop condition is false. Execution continues on line 272
  257 |     while (skip[ell] + k < m) {
      |     ^
source/algos/akc.c:273:5: note: Loop condition is true.  Entering loop body
  273 |     while (skip[ell] < m) {
      |     ^
source/algos/akc.c:274:7: note: The value 0 is assigned to 'i'
  274 |       i = 0;
      |       ^~~~~
source/algos/akc.c:275:7: note: Loop condition is true.  Entering loop body
  275 |       while (loc[i] >= skip[ell]) {
      |       ^
source/algos/akc.c:276:24: note: The left operand of '>' is a garbage value
  276 |         while (next[i] > loc[i] - skip[ell]) {
      |                ~~~~~~~ ^
source/algos/askip.c:109:29: warning: Result of 'calloc' is converted to a pointer of type 'char', which is incompatible with sizeof operand type 'int' [clang-analyzer-unix.MallocSizeof]
  109 |   automaton->term = (char *)calloc(size, sizeof(int));
      |                      ~~~~~~ ^~~~~~       ~~~~~~~~~~~
source/algos/askip.c:109:29: note: Result of 'calloc' is converted to a pointer of type 'char', which is incompatible with sizeof operand type 'int'
  109 |   automaton->term = (char *)calloc(size, sizeof(int));
      |                      ~~~~~~ ^~~~~~       ~~~~~~~~~~~
source/algos/askip.c:149:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  149 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/askip.c:149:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  149 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/aut.c:34:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   34 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/aut.c:34:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   34 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/blim.c:45:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   45 |   memset(M, 0xff, sizeof(unsigned long) * SIGMA * wsize);
      |   ^~~~~~
source/algos/blim.c:45:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   45 |   memset(M, 0xff, sizeof(unsigned long) * SIGMA * wsize);
      |   ^~~~~~
source/algos/bm.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/bm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/bm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/bm.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/bm.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/bm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/bm.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/bm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/bm.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/bm.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/bm.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/bm.c:87:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   87 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/bm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/bm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/bm.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/bm.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/bm.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/bm.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/bm.c:74:3: note: Returning from 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:76:3: note: Assuming 'pre_time' is null
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/bm.c:76:3: note: Taking false branch
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/bm.c:82:10: note: Assuming the condition is true
   82 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/bm.c:82:3: note: Loop condition is true.  Entering loop body
   82 |   while (j <= n - m) {
      |   ^
source/algos/bm.c:83:21: note: 'i' is < 0
   83 |     for (i = m - 1; i >= 0 && x[i] == y[i + j]; --i)
      |                     ^
source/algos/bm.c:83:28: note: Left side of '&&' is false
   83 |     for (i = m - 1; i >= 0 && x[i] == y[i + j]; --i)
      |                            ^
source/algos/bm.c:85:9: note: 'i' is < 0
   85 |     if (i < 0) {
      |         ^
source/algos/bm.c:85:5: note: Taking true branch
   85 |     if (i < 0) {
      |     ^
source/algos/bm.c:87:9: note: Assigned value is garbage or undefined
   87 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/bndm.c:89:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   89 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bndm.c:89:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   89 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bom.c:83:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   83 |   memset(L, 0, (m + 1) * sizeof(List));
      |   ^~~~~~
source/algos/bom.c:83:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   83 |   memset(L, 0, (m + 1) * sizeof(List));
      |   ^~~~~~
source/algos/bom.c:84:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   84 |   memset(T, FALSE, (m + 1) * sizeof(char));
      |   ^~~~~~
source/algos/bom.c:84:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   84 |   memset(T, FALSE, (m + 1) * sizeof(char));
      |   ^~~~~~
source/algos/bom.c:112:3: warning: Potential memory leak [clang-analyzer-unix.Malloc]
  112 |   END_SEARCHING
      |   ^
source/algos/include/main.h:53:5: note: expanded from macro 'END_SEARCHING'
   53 |     timer_stop(_timer);                                                        \
      |     ^
source/algos/bom.c:85:3: note: Calling 'oracle'
   85 |   oracle(x, m, T, L);
      |   ^~~~~~~~~~~~~~~~~~
source/algos/bom.c:60:15: note: Assuming 'i' is > 0
   60 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom.c:63:12: note: Assuming 'p' is > 'm'
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |            ^~~~~~
source/algos/bom.c:63:19: note: Left side of '&&' is false
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |                   ^
source/algos/bom.c:67:17: note: '?' condition is true
   67 |     S[i - 1] = (p == m + 1 ? m : q);
      |                 ^
source/algos/bom.c:60:15: note: Assuming 'i' is > 0
   60 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom.c:63:12: note: 'p' is <= 'm'
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |            ^
source/algos/bom.c:63:12: note: Left side of '&&' is true
source/algos/bom.c:63:22: note: Assuming the condition is true
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/bom.c:63:5: note: Loop condition is true.  Entering loop body
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |     ^
source/algos/bom.c:64:7: note: Calling 'setTransition'
   64 |       setTransition(p, i - 1, L);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/bom.c:47:16: note: Memory is allocated
   47 |   cell = (List)malloc(sizeof(struct _cell));
      |                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/bom.c:48:7: note: Assuming 'cell' is not equal to NULL
   48 |   if (cell == NULL)
      |       ^~~~~~~~~~~~
source/algos/bom.c:48:3: note: Taking false branch
   48 |   if (cell == NULL)
      |   ^
source/algos/bom.c:64:7: note: Returned allocated memory
   64 |       setTransition(p, i - 1, L);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/bom.c:63:12: note: Assuming 'p' is > 'm'
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |            ^~~~~~
source/algos/bom.c:63:19: note: Left side of '&&' is false
   63 |     while (p <= m && (q = getTransition(x, p, L, c)) == UNDEFINED) {
      |                   ^
source/algos/bom.c:67:17: note: Assuming the condition is false
   67 |     S[i - 1] = (p == m + 1 ? m : q);
      |                 ^~~~~~~~~~
source/algos/bom.c:67:17: note: '?' condition is false
source/algos/bom.c:60:15: note: Assuming 'i' is <= 0
   60 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom.c:60:3: note: Loop condition is false. Execution continues on line 69
   60 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom.c:70:3: note: Loop condition is true.  Entering loop body
   70 |   while (p <= m) {
      |   ^
source/algos/bom.c:70:10: note: Assuming 'p' is > 'm'
   70 |   while (p <= m) {
      |          ^~~~~~
source/algos/bom.c:70:3: note: Loop condition is false. Execution continues on line 70
   70 |   while (p <= m) {
      |   ^
source/algos/bom.c:85:3: note: Returned allocated memory
   85 |   oracle(x, m, T, L);
      |   ^~~~~~~~~~~~~~~~~~
source/algos/bom.c:86:3: note: Assuming 'pre_time' is null
   86 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/bom.c:86:3: note: Taking false branch
   86 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/bom.c:92:10: note: Assuming the condition is false
   92 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/bom.c:92:3: note: Loop condition is false. Execution continues on line 110
   92 |   while (j <= n - m) {
      |   ^
source/algos/bom.c:110:3: note: Loop condition is true.  Entering loop body
  110 |   for (i = 0; i <= m; i++)
      |   ^
source/algos/bom.c:110:3: note: Loop condition is true.  Entering loop body
source/algos/bom.c:110:3: note: Loop condition is true.  Entering loop body
source/algos/bom.c:110:3: note: Loop condition is false. Execution continues on line 112
source/algos/bom.c:112:3: note: Potential memory leak
  112 |   END_SEARCHING
      |   ^
source/algos/include/main.h:53:5: note: expanded from macro 'END_SEARCHING'
   53 |     timer_stop(_timer);                                                        \
      |     ^
source/algos/bom2.c:49:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   49 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/bom2.c:38:15: note: Assuming the condition is false
   38 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/bom2.c:38:3: note: Loop condition is false. Execution continues on line 42
   38 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/bom2.c:42:3: note: Loop condition is false. Execution continues on line 45
   42 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/bom2.c:46:8: note: Value assigned to 'i'
   46 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/bom2.c:46:15: note: Assuming 'i' is > 0
   46 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom2.c:46:3: note: Loop condition is true.  Entering loop body
   46 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom2.c:49:17: note: Array access results in an undefined pointer dereference
   49 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/bom2.c:67:31: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   67 |     while (i + j >= 0 && (q = trans[p][y[i + j]]) != UNDEFINED) {
      |                               ^~~~~~~~~~~~~~~~~~
source/algos/bom2.c:38:15: note: Assuming the condition is false
   38 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/bom2.c:38:3: note: Loop condition is false. Execution continues on line 42
   38 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/bom2.c:42:3: note: Loop condition is false. Execution continues on line 45
   42 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/bom2.c:46:15: note: Assuming 'i' is <= 0
   46 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom2.c:46:3: note: Loop condition is false. Execution continues on line 57
   46 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom2.c:57:3: note: Assuming 'pre_time' is null
   57 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/bom2.c:57:3: note: Taking false branch
   57 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/bom2.c:64:10: note: Assuming 'j' is <= 'nMinusm'
   64 |   while (j <= nMinusm) {
      |          ^~~~~~~~~~~~
source/algos/bom2.c:64:3: note: Loop condition is true.  Entering loop body
   64 |   while (j <= nMinusm) {
      |   ^
source/algos/bom2.c:66:5: note: Value assigned to 'p'
   66 |     p = m;
      |     ^~~~~
source/algos/bom2.c:67:12: note: Assuming the condition is true
   67 |     while (i + j >= 0 && (q = trans[p][y[i + j]]) != UNDEFINED) {
      |            ^~~~~~~~~~
source/algos/bom2.c:67:12: note: Left side of '&&' is true
source/algos/bom2.c:67:31: note: Array access results in an undefined pointer dereference
   67 |     while (i + j >= 0 && (q = trans[p][y[i + j]]) != UNDEFINED) {
      |                               ^~~~~~~~~~~~~~~~~~
source/algos/bww.c:42:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   42 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:42:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   42 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:51:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   51 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:51:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   51 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:123:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  123 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:123:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  123 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:132:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  132 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:132:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  132 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:49:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   49 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:49:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   49 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:55:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   55 |   memset(rmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:55:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   55 |   memset(rmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:57:21: warning: The left operand of '==' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   57 |     if (hmax[i + 1] == m)
      |                     ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking true branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is < 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:19: note: Assuming 'i' is >= 0
   56 |   for (i = m - 1; i >= 0; --i) {
      |                   ^~~~~~
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:21: note: The left operand of '==' is a garbage value due to array index out of bounds
   57 |     if (hmax[i + 1] == m)
      |         ~~~~~~~~~~~ ^
source/algos/colussi.c:94:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   94 |     next[i] = nhd0[m - rmin[h[i]]];
      |             ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is true
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is true.  Entering loop body
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking false branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is >= 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is true.  Entering loop body
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:51:5: note: Taking false branch
   51 |     if (hmax[i] < m)
      |     ^
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:5: note: Taking false branch
   57 |     if (hmax[i + 1] == m)
      |     ^
source/algos/colussi.c:59:9: note: Assuming the condition is true
   59 |     if (kmin[i] == 0)
      |         ^~~~~~~~~~~~
source/algos/colussi.c:59:5: note: Taking true branch
   59 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:56:3: note: Loop condition is false. Execution continues on line 66
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:68:3: note: Loop condition is true.  Entering loop body
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:69:5: note: Taking true branch
   69 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:68:3: note: Loop condition is false. Execution continues on line 73
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is false. Execution continues on line 78
   76 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:78:3: note: Loop condition is true.  Entering loop body
   78 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:78:3: note: Loop condition is false. Execution continues on line 80
source/algos/colussi.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:86:5: note: Taking false branch
   86 |     if (kmin[i] > 0)
      |     ^
source/algos/colussi.c:84:3: note: Loop condition is false. Execution continues on line 91
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is false. Execution continues on line 93
   91 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:93:3: note: Loop condition is true.  Entering loop body
   93 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:94:13: note: Assigned value is garbage or undefined
   94 |     next[i] = nhd0[m - rmin[h[i]]];
      |             ^ ~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:95:11: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   95 |   next[m] = nhd0[m - rmin[h[m - 1]]];
      |           ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking true branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is >= 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is true.  Entering loop body
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:51:5: note: Taking false branch
   51 |     if (hmax[i] < m)
      |     ^
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:5: note: Taking true branch
   57 |     if (hmax[i + 1] == m)
      |     ^
source/algos/colussi.c:59:9: note: Assuming the condition is false
   59 |     if (kmin[i] == 0)
      |         ^~~~~~~~~~~~
source/algos/colussi.c:59:5: note: Taking false branch
   59 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:56:3: note: Loop condition is false. Execution continues on line 66
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:68:3: note: Loop condition is true.  Entering loop body
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:69:5: note: Taking false branch
   69 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:68:3: note: Loop condition is false. Execution continues on line 73
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is true.  Entering loop body
   76 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is false. Execution continues on line 78
source/algos/colussi.c:78:3: note: Loop condition is false. Execution continues on line 80
   78 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:86:9: note: Assuming the condition is false
   86 |     if (kmin[i] > 0)
      |         ^~~~~~~~~~~
source/algos/colussi.c:86:5: note: Taking false branch
   86 |     if (kmin[i] > 0)
      |     ^
source/algos/colussi.c:84:3: note: Loop condition is false. Execution continues on line 91
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is true.  Entering loop body
   91 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is false. Execution continues on line 93
source/algos/colussi.c:93:3: note: Loop condition is false. Execution continues on line 95
   93 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:95:11: note: Assigned value is garbage or undefined
   95 |   next[m] = nhd0[m - rmin[h[m - 1]]];
      |           ^ ~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/dfdm.c:38:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   38 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/dfdm.c:38:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   38 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ebom.c:49:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   49 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/ebom.c:36:7: note: Assuming 'm' is >= 2
   36 |   if (m < 2)
      |       ^~~~~
source/algos/ebom.c:36:3: note: Taking false branch
   36 |   if (m < 2)
      |   ^
source/algos/ebom.c:40:15: note: Assuming the condition is false
   40 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/ebom.c:40:3: note: Loop condition is false. Execution continues on line 42
   40 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/ebom.c:42:3: note: Loop condition is false. Execution continues on line 45
   42 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/ebom.c:46:8: note: The value 2147483647 is assigned to 'i'
   46 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/ebom.c:46:3: note: Loop condition is true.  Entering loop body
   46 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/ebom.c:49:17: note: Array access results in an undefined pointer dereference
   49 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/epsm.c:246:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  246 |   memset(flist, 0, sizeof(LIST *) * 2048);
      |   ^~~~~~
source/algos/epsm.c:246:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  246 |   memset(flist, 0, sizeof(LIST *) * 2048);
      |   ^~~~~~
source/algos/epsm.c:248:34: warning: Potential memory leak [clang-analyzer-unix.Malloc]
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |                                  ^
source/algos/epsm.c:340:7: note: Assuming 'patlen' is >= 2
  340 |   if (patlen < 2)
      |       ^~~~~~~~~~
source/algos/epsm.c:340:3: note: Taking false branch
  340 |   if (patlen < 2)
      |   ^
source/algos/epsm.c:342:7: note: Assuming 'patlen' is not equal to 2
  342 |   if (patlen == 2)
      |       ^~~~~~~~~~~
source/algos/epsm.c:342:3: note: Taking false branch
  342 |   if (patlen == 2)
      |   ^
source/algos/epsm.c:344:7: note: Assuming 'patlen' is not equal to 3
  344 |   if (patlen == 3)
      |       ^~~~~~~~~~~
source/algos/epsm.c:344:3: note: Taking false branch
  344 |   if (patlen == 3)
      |   ^
source/algos/epsm.c:346:7: note: Assuming 'patlen' is not equal to 4
  346 |   if (patlen == 4)
      |       ^~~~~~~~~~~
source/algos/epsm.c:346:3: note: Taking false branch
  346 |   if (patlen == 4)
      |   ^
source/algos/epsm.c:348:7: note: Assuming 'patlen' is >= 16
  348 |   if (patlen >= 16)
      |       ^~~~~~~~~~~~
source/algos/epsm.c:348:3: note: Taking true branch
  348 |   if (patlen >= 16)
      |   ^
source/algos/epsm.c:349:12: note: Calling 'search16'
  349 |     return search16(pattern, patlen, x, textlen);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:248:15: note: Assuming the condition is true
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |               ^~~~~~~~~~~~~~~~~
source/algos/epsm.c:248:3: note: Loop condition is true.  Entering loop body
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |   ^
source/algos/epsm.c:253:9: note: Assuming the condition is true
  253 |     if (flist[filter] == 0) {
      |         ^~~~~~~~~~~~~~~~~~
source/algos/epsm.c:253:5: note: Taking true branch
  253 |     if (flist[filter] == 0) {
      |     ^
source/algos/epsm.c:254:31: note: Memory is allocated
  254 |       flist[filter] = (LIST *)malloc(sizeof(LIST));
      |                               ^~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:255:11: note: Assuming the condition is true
  255 |       if (flist[filter]) {
      |           ^~~~~~~~~~~~~
source/algos/epsm.c:255:7: note: Taking true branch
  255 |       if (flist[filter]) {
      |       ^
source/algos/epsm.c:248:15: note: Assuming the condition is true
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |               ^~~~~~~~~~~~~~~~~
source/algos/epsm.c:248:3: note: Loop condition is true.  Entering loop body
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |   ^
source/algos/epsm.c:253:9: note: Assuming the condition is true
  253 |     if (flist[filter] == 0) {
      |         ^~~~~~~~~~~~~~~~~~
source/algos/epsm.c:253:5: note: Taking true branch
  253 |     if (flist[filter] == 0) {
      |     ^
source/algos/epsm.c:255:11: note: Assuming the condition is false
  255 |       if (flist[filter]) {
      |           ^~~~~~~~~~~~~
source/algos/epsm.c:255:7: note: Taking false branch
  255 |       if (flist[filter]) {
      |       ^
source/algos/epsm.c:248:34: note: Potential memory leak
  248 |   for (i = 1; i < tmppatlen - 7; i++) {
      |                                  ^
source/algos/fbom.c:48:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   48 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/fbom.c:39:15: note: Assuming the condition is false
   39 |   for (i = 0; i <= m + 1; i++)
      |               ^~~~~~~~~~
source/algos/fbom.c:39:3: note: Loop condition is false. Execution continues on line 41
   39 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/fbom.c:41:3: note: Loop condition is false. Execution continues on line 44
   41 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/fbom.c:45:8: note: Value assigned to 'i'
   45 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/fbom.c:45:15: note: Assuming 'i' is > 0
   45 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/fbom.c:45:3: note: Loop condition is true.  Entering loop body
   45 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/fbom.c:48:17: note: Array access results in an undefined pointer dereference
   48 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/fdm.c:36:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   36 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/fdm.c:36:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   36 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ffs.c:41:7: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   41 |     i = temx[last];
      |       ^
source/algos/ffs.c:66:3: note: Calling 'Forward_Suffix_Function'
   66 |   Forward_Suffix_Function(x, m, gs, SIGMA);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ffs.c:34:15: note: Assuming 'i' is >= 'm'
   34 |   for (i = 0; i < m; i++)
      |               ^~~~~
source/algos/ffs.c:34:3: note: Loop condition is false. Execution continues on line 37
   34 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ffs.c:37:15: note: 'i' is >= 'm'
   37 |   for (i = 0; i < m; i++)
      |               ^
source/algos/ffs.c:37:3: note: Loop condition is false. Execution continues on line 39
   37 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ffs.c:39:24: note: Assuming 'suffix_len' is <= 'm'
   39 |   for (suffix_len = 0; suffix_len <= m; suffix_len++) {
      |                        ^~~~~~~~~~~~~~~
source/algos/ffs.c:39:3: note: Loop condition is true.  Entering loop body
   39 |   for (suffix_len = 0; suffix_len <= m; suffix_len++) {
      |   ^
source/algos/ffs.c:40:5: note: The value -1 is assigned to 'last'
   40 |     last = m - 1;
      |     ^~~~~~~~~~~~
source/algos/ffs.c:41:7: note: Assigned value is garbage or undefined
   41 |     i = temx[last];
      |       ^ ~~~~~~~~~~
source/algos/fs-w6.c:108:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
  108 |   s3 = q;
      |   ^    ~
source/algos/fs-w6.c:108:3: note: Value stored to 's3' is never read
  108 |   s3 = q;
      |   ^    ~
source/algos/fs-w6.c:110:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
  110 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w6.c:110:3: note: Value stored to 's5' is never read
  110 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:104:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
  104 |   s3 = q;
      |   ^    ~
source/algos/fs-w8.c:104:3: note: Value stored to 's3' is never read
  104 |   s3 = q;
      |   ^    ~
source/algos/fs-w8.c:106:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
  106 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:106:3: note: Value stored to 's5' is never read
  106 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:108:3: warning: Value stored to 's7' is never read [clang-analyzer-deadcode.DeadStores]
  108 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:108:3: note: Value stored to 's7' is never read
  108 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:86:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
   86 |   s3 = q;
      |   ^    ~
source/algos/fsbndm-w8.c:86:3: note: Value stored to 's3' is never read
   86 |   s3 = q;
      |   ^    ~
source/algos/fsbndm-w8.c:88:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
   88 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:88:3: note: Value stored to 's5' is never read
   88 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:90:3: warning: Value stored to 's7' is never read [clang-analyzer-deadcode.DeadStores]
   90 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:90:3: note: Value stored to 's7' is never read
   90 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/gg.c:50:4: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   50 |    memset(kmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:50:4: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   50 |    memset(kmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:56:4: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   56 |    memset(rmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:56:4: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   56 |    memset(rmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:58:23: warning: The left operand of '==' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   58 |       if (hmax[i + 1] == m)
      |                       ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking true branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: 'i' is < 1
   51 |    for (i = m; i >= 1; --i)
      |                ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:20: note: Assuming 'i' is >= 0
   57 |    for (i = m - 1; i >= 0; --i) {
      |                    ^~~~~~
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:23: note: The left operand of '==' is a garbage value due to array index out of bounds
   58 |       if (hmax[i + 1] == m)
      |           ~~~~~~~~~~~ ^
source/algos/gg.c:95:15: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   95 |       next[i] = nhd0[m - rmin[h[i]]];
      |               ^
source/algos/gg.c:107:17: note: Assuming the condition is true
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is true.  Entering loop body
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is true
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is true.  Entering loop body
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking false branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: Assuming 'i' is >= 1
   51 |    for (i = m; i >= 1; --i)
      |                ^~~~~~
source/algos/gg.c:51:4: note: Loop condition is true.  Entering loop body
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:52:7: note: Taking false branch
   52 |       if (hmax[i] < m)
      |       ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:7: note: Taking false branch
   58 |       if (hmax[i + 1] == m)
      |       ^
source/algos/gg.c:60:11: note: Assuming the condition is true
   60 |       if (kmin[i] == 0)
      |           ^~~~~~~~~~~~
source/algos/gg.c:60:7: note: Taking true branch
   60 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:57:4: note: Loop condition is false. Execution continues on line 67
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:69:4: note: Loop condition is true.  Entering loop body
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:70:7: note: Taking true branch
   70 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:69:4: note: Loop condition is false. Execution continues on line 74
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is false. Execution continues on line 79
   77 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:79:4: note: Loop condition is true.  Entering loop body
   79 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:79:4: note: Loop condition is false. Execution continues on line 81
source/algos/gg.c:85:4: note: Loop condition is true.  Entering loop body
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:87:7: note: Taking false branch
   87 |       if (kmin[i] > 0)
      |       ^
source/algos/gg.c:85:4: note: Loop condition is false. Execution continues on line 92
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:92:4: note: Loop condition is false. Execution continues on line 94
   92 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:94:4: note: Loop condition is true.  Entering loop body
   94 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:95:15: note: Assigned value is garbage or undefined
   95 |       next[i] = nhd0[m - rmin[h[i]]];
      |               ^ ~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:96:12: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   96 |    next[m] = nhd0[m - rmin[h[m - 1]]];
      |            ^
source/algos/gg.c:107:17: note: Assuming the condition is true
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is true.  Entering loop body
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is true
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is true.  Entering loop body
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking false branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: Assuming 'i' is >= 1
   51 |    for (i = m; i >= 1; --i)
      |                ^~~~~~
source/algos/gg.c:51:4: note: Loop condition is true.  Entering loop body
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:52:7: note: Taking false branch
   52 |       if (hmax[i] < m)
      |       ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:7: note: Taking false branch
   58 |       if (hmax[i + 1] == m)
      |       ^
source/algos/gg.c:60:11: note: Assuming the condition is false
   60 |       if (kmin[i] == 0)
      |           ^~~~~~~~~~~~
source/algos/gg.c:60:7: note: Taking false branch
   60 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:57:4: note: Loop condition is false. Execution continues on line 67
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:69:4: note: Loop condition is true.  Entering loop body
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:70:7: note: Taking false branch
   70 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:69:4: note: Loop condition is false. Execution continues on line 74
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is true.  Entering loop body
   77 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is false. Execution continues on line 79
source/algos/gg.c:79:4: note: Loop condition is false. Execution continues on line 81
   79 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:85:4: note: Loop condition is true.  Entering loop body
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:87:11: note: Assuming the condition is false
   87 |       if (kmin[i] > 0)
      |           ^~~~~~~~~~~
source/algos/gg.c:87:7: note: Taking false branch
   87 |       if (kmin[i] > 0)
      |       ^
source/algos/gg.c:85:4: note: Loop condition is false. Execution continues on line 92
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:92:4: note: Loop condition is true.  Entering loop body
   92 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:92:4: note: Loop condition is false. Execution continues on line 94
source/algos/gg.c:94:4: note: Loop condition is false. Execution continues on line 96
   94 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:96:12: note: Assigned value is garbage or undefined
   96 |    next[m] = nhd0[m - rmin[h[m - 1]]];
      |            ^ ~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:146:11: warning: Value stored to 'heavy' is never read [clang-analyzer-deadcode.DeadStores]
  146 |           heavy = 0;
      |           ^       ~
source/algos/gg.c:146:11: note: Value stored to 'heavy' is never read
  146 |           heavy = 0;
      |           ^       ~
source/algos/hash3.c:63:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   63 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash3.c:63:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   63 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash5.c:70:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   70 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash5.c:70:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   70 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash8.c:80:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   80 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash8.c:80:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   80 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/ildm1.c:36:25: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
   36 |   xR = (unsigned char *)malloc(sizeof(char) * (m + 1));
      |         ~~~~~~~~~~~~~~~ ^~~~~~ ~~~~~~~~~~~~
source/algos/ildm1.c:36:25: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
   36 |   xR = (unsigned char *)malloc(sizeof(char) * (m + 1));
      |         ~~~~~~~~~~~~~~~ ^~~~~~ ~~~~~~~~~~~~
source/algos/ildm1.c:44:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   44 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:44:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   44 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:47:32: warning: Result of 'calloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
   47 |   tterminal = (unsigned char *)calloc(3 * m, sizeof(char));
      |                ~~~~~~~~~~~~~~~ ^~~~~~        ~~~~~~~~~~~~
source/algos/ildm1.c:47:32: note: Result of 'calloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
   47 |   tterminal = (unsigned char *)calloc(3 * m, sizeof(char));
      |                ~~~~~~~~~~~~~~~ ^~~~~~        ~~~~~~~~~~~~
source/algos/ildm1.c:50:22: warning: Potential leak of memory pointed to by 'xR' [clang-analyzer-unix.Malloc]
   50 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ildm1.c:36:25: note: Memory is allocated
   36 |   xR = (unsigned char *)malloc(sizeof(char) * (m + 1));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ildm1.c:37:15: note: Assuming 'i' is >= 'm'
   37 |   for (i = 0; i < m; i++)
      |               ^~~~~
source/algos/ildm1.c:37:3: note: Loop condition is false. Execution continues on line 39
   37 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ildm1.c:50:22: note: Potential leak of memory pointed to by 'xR'
   50 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ildm1.c:51:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   51 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:51:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   51 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:56:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   56 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:56:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   56 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:61:22: warning: Potential leak of memory pointed to by 'xR' [clang-analyzer-unix.Malloc]
   61 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ildm2.c:49:25: note: Memory is allocated
   49 |   xR = (unsigned char *)malloc(sizeof(unsigned char) * (m + 1));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ildm2.c:50:15: note: Assuming 'i' is >= 'm'
   50 |   for (i = 0; i < m; i++)
      |               ^~~~~
source/algos/ildm2.c:50:3: note: Loop condition is false. Execution continues on line 52
   50 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ildm2.c:61:22: note: Potential leak of memory pointed to by 'xR'
   61 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ildm2.c:62:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   62 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:62:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   62 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/kmp.c:63:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   63 |       i = kmpNext[i];
      |         ^ ~~~~~~~~~~
source/algos/kmp.c:49:3: note: Calling 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmp.c:32:10: note: Assuming 'i' is >= 'm'
   32 |   while (i < m) {
      |          ^~~~~
source/algos/kmp.c:32:3: note: Loop condition is false. Execution continues on line 32
   32 |   while (i < m) {
      |   ^
source/algos/kmp.c:49:3: note: Returning from 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmp.c:50:3: note: Assuming 'pre_time' is null
   50 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/kmp.c:50:3: note: Taking false branch
   50 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/kmp.c:56:10: note: Assuming 'j' is < 'n'
   56 |   while (j < n) {
      |          ^~~~~
source/algos/kmp.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   while (j < n) {
      |   ^
source/algos/kmp.c:57:12: note: Left side of '&&' is true
   57 |     while (i > -1 && x[i] != y[j])
      |            ^
source/algos/kmp.c:57:22: note: Assuming the condition is false
   57 |     while (i > -1 && x[i] != y[j])
      |                      ^~~~~~~~~~~~
source/algos/kmp.c:57:5: note: Loop condition is false. Execution continues on line 59
   57 |     while (i > -1 && x[i] != y[j])
      |     ^
source/algos/kmp.c:59:5: note: The value 1 is assigned to 'i'
   59 |     i++;
      |     ^~~
source/algos/kmp.c:61:9: note: 'i' is >= 'm'
   61 |     if (i >= m) {
      |         ^
source/algos/kmp.c:61:5: note: Taking true branch
   61 |     if (i >= m) {
      |     ^
source/algos/kmp.c:63:9: note: Assigned value is garbage or undefined
   63 |       i = kmpNext[i];
      |         ^ ~~~~~~~~~~
source/algos/kmpskip.c:74:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   74 |   memset(z, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:74:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   74 |   memset(z, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:75:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   75 |   memset(list, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:75:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   75 |   memset(list, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:88:3: warning: Value stored to 'i' is never read [clang-analyzer-deadcode.DeadStores]
   88 |   i = j = -1;
      |   ^   ~~~~~~
source/algos/kmpskip.c:88:3: note: Value stored to 'i' is never read
   88 |   i = j = -1;
      |   ^   ~~~~~~
source/algos/kmpskip.c:136:24: warning: The right operand of '-' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
  136 |         kmpStart += (k - mpNext[k]);
      |                        ^ ~~~~~~~~~
source/algos/kmpskip.c:72:3: note: Calling 'preMp'
   72 |   preMp((char*)x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:51:10: note: Assuming 'i' is >= 'm'
   51 |   while (i < m) {
      |          ^~~~~
source/algos/kmpskip.c:51:3: note: Loop condition is false. Execution continues on line 51
   51 |   while (i < m) {
      |   ^
source/algos/kmpskip.c:72:3: note: Returning from 'preMp'
   72 |   preMp((char*)x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:73:3: note: Calling 'preKmp'
   73 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:33:7: note: Assigning -1
   33 |   j = kmpNext[0] = -1;
      |       ^~~~~~~~~~~~~~~
source/algos/kmpskip.c:34:10: note: 'i' is >= 'm'
   34 |   while (i < m) {
      |          ^
source/algos/kmpskip.c:34:3: note: Loop condition is false. Execution continues on line 34
   34 |   while (i < m) {
      |   ^
source/algos/kmpskip.c:73:3: note: Returning from 'preKmp'
   73 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:77:15: note: 'i' is >= 'm'
   77 |   for (i = 1; i < m; ++i) {
      |               ^
source/algos/kmpskip.c:77:3: note: Loop condition is false. Execution continues on line 81
   77 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/kmpskip.c:81:3: note: Assuming 'pre_time' is null
   81 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/kmpskip.c:81:3: note: Taking false branch
   81 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/kmpskip.c:91:12: note: Assuming 'j' is < 'n'
   91 |   } while (j < n && z[y[j]] < 0);
      |            ^~~~~
source/algos/kmpskip.c:91:12: note: Left side of '&&' is true
source/algos/kmpskip.c:89:3: note: Loop condition is false.  Exiting loop
   89 |   do {
      |   ^
source/algos/kmpskip.c:92:7: note: Assuming 'j' is < 'n'
   92 |   if (j >= n) {
      |       ^~~~~~
source/algos/kmpskip.c:92:3: note: Taking false branch
   92 |   if (j >= n) {
      |   ^
source/algos/kmpskip.c:98:10: note: Assuming the condition is true
   98 |   while (start <= n - m) {
      |          ^~~~~~~~~~~~~~
source/algos/kmpskip.c:98:3: note: Loop condition is true.  Entering loop body
   98 |   while (start <= n - m) {
      |   ^
source/algos/kmpskip.c:99:9: note: Assuming 'start' is > 'wall'
   99 |     if (start > wall)
      |         ^~~~~~~~~~~~
source/algos/kmpskip.c:99:5: note: Taking true branch
   99 |     if (start > wall)
      |     ^
source/algos/kmpskip.c:101:9: note: Calling 'attempt'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:60:3: note: The value 0 is assigned to 'k'
   60 |   k = wall - start;
      |   ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:61:10: note: 'k' is >= 'm'
   61 |   while (k < m && x[k] == y[k + start])
      |          ^
source/algos/kmpskip.c:61:16: note: Left side of '&&' is false
   61 |   while (k < m && x[k] == y[k + start])
      |                ^
source/algos/kmpskip.c:63:3: note: Returning zero (loaded from 'k')
   63 |   return (k);
      |   ^~~~~~~~~~
source/algos/kmpskip.c:101:9: note: Returning from 'attempt'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:101:5: note: The value 0 is assigned to 'k'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:103:9: note: Assuming 'k' is not equal to 'm'
  103 |     if (k == m) {
      |         ^~~~~~
source/algos/kmpskip.c:103:5: note: Taking false branch
  103 |     if (k == m) {
      |     ^
source/algos/kmpskip.c:108:9: note: Assuming 'i' is >= 0
  108 |     if (i < 0) {
      |         ^~~~~
source/algos/kmpskip.c:108:5: note: Taking false branch
  108 |     if (i < 0) {
      |     ^
source/algos/kmpskip.c:119:5: note: The value -1 is assigned to 'k'
  119 |     k = kmpNext[k];
      |     ^~~~~~~~~~~~~~
source/algos/kmpskip.c:121:12: note: Assuming 'start' is >= 'kmpStart'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |            ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:121:12: note: Left side of '||' is false
source/algos/kmpskip.c:121:33: note: Assuming 'kmpStart' is < 'start'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |                                 ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:121:33: note: Left side of '&&' is true
source/algos/kmpskip.c:121:53: note: Assuming 'start' is < 'wall'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |                                                     ^~~~~~~~~~~~
source/algos/kmpskip.c:121:5: note: Loop condition is true.  Entering loop body
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |     ^
source/algos/kmpskip.c:122:11: note: 'start' is >= 'kmpStart'
  122 |       if (start < kmpStart) {
      |           ^~~~~
source/algos/kmpskip.c:122:7: note: Taking false branch
  122 |       if (start < kmpStart) {
      |       ^
source/algos/kmpskip.c:136:24: note: The right operand of '-' is a garbage value due to array index out of bounds
  136 |         kmpStart += (k - mpNext[k]);
      |                        ^ ~~~~~~~~~
source/algos/ldm.c:41:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   41 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:41:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   41 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:44:32: warning: Result of 'calloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
   44 |   tterminal = (unsigned char *)calloc(3 * m, sizeof(char));
      |                ~~~~~~~~~~~~~~~ ^~~~~~        ~~~~~~~~~~~~
source/algos/ldm.c:44:32: note: Result of 'calloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
   44 |   tterminal = (unsigned char *)calloc(3 * m, sizeof(char));
      |                ~~~~~~~~~~~~~~~ ^~~~~~        ~~~~~~~~~~~~
source/algos/ldm.c:47:22: warning: Potential leak of memory pointed to by 'xR' [clang-analyzer-unix.Malloc]
   47 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ldm.c:39:8: note: Calling 'ureverse'
   39 |   xR = ureverse(x, m);
      |        ^~~~~~~~~~~~~~
source/algos/include/AUTOMATON.h:68:25: note: Memory is allocated
   68 |   xR = (unsigned char *)malloc((m + 1) * sizeof(unsigned char));
      |                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/include/AUTOMATON.h:69:15: note: Assuming 'i' is >= 'm'
   69 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/include/AUTOMATON.h:69:3: note: Loop condition is false. Execution continues on line 71
   69 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/ldm.c:39:8: note: Returned allocated memory
   39 |   xR = ureverse(x, m);
      |        ^~~~~~~~~~~~~~
source/algos/ldm.c:47:22: note: Potential leak of memory pointed to by 'xR'
   47 |   ttransSMA = (int *)malloc((m + 1) * SIGMA * sizeof(int));
      |                      ^
source/algos/ldm.c:48:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   48 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:48:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   48 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/mp.c:56:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   56 |       i = mpNext[i];
      |         ^ ~~~~~~~~~
source/algos/mp.c:42:3: note: Calling 'preMp'
   42 |   preMp(x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/mp.c:30:10: note: Assuming 'i' is >= 'm'
   30 |   while (i < m) {
      |          ^~~~~
source/algos/mp.c:30:3: note: Loop condition is false. Execution continues on line 30
   30 |   while (i < m) {
      |   ^
source/algos/mp.c:42:3: note: Returning from 'preMp'
   42 |   preMp(x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/mp.c:43:3: note: Assuming 'pre_time' is null
   43 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:9: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/mp.c:43:3: note: Taking false branch
   43 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:48:5: note: expanded from macro 'END_PREPROCESSING'
   48 |     if (pre_time)                                                              \
      |     ^
source/algos/mp.c:49:10: note: Assuming 'j' is < 'n'
   49 |   while (j < n) {
      |          ^~~~~
source/algos/mp.c:49:3: note: Loop condition is true.  Entering loop body
   49 |   while (j < n) {
      |   ^
source/algos/mp.c:50:12: note: Left side of '&&' is true
   50 |     while (i > -1 && x[i] != y[j])
      |            ^
source/algos/mp.c:50:22: note: Assuming the condition is false
   50 |     while (i > -1 && x[i] != y[j])
      |                      ^~~~~~~~~~~~
source/algos/mp.c:50:5: note: Loop condition is false. Execution continues on line 52
   50 |     while (i > -1 && x[i] != y[j])
      |     ^
source/algos/mp.c:52:5: note: The value 1 is assigned to 'i'
   52 |     i++;
      |     ^~~
source/algos/mp.c:54:9: note: 'i' is >= 'm'
   54 |     if (i >= m) {
      |         ^
source/algos/mp.c:54:5: note: Taking true branch
   54 |     if (i >= m) {
      |     ^
source/algos/mp.c:56:9: note: Assigned value is garbage or undefined
   56 |       i = mpNext[i];
      |         ^ ~~~~~~~~~
source/algos/rcolussi.c:71:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   71 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/rcolussi.c:71:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   71 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/rf.c:55:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   55 |       memcpy(ttrans + r * SIGMA, ttrans + getTarget(p, c) * SIGMA,
      |       ^~~~~~
source/algos/rf.c:55:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   55 |       memcpy(ttrans + r * SIGMA, ttrans + getTarget(p, c) * SIGMA,
      |       ^~~~~~
source/algos/rf.c:90:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   90 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/rf.c:90:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   90 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/sbndm-bmh.c:52:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
   52 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:52:3: note: Value stored to 's' is never read
   52 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:127:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
  127 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:127:3: note: Value stored to 's' is never read
  127 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:51:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
   51 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:51:3: note: Value stored to 's' is never read
   51 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:122:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
  122 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:122:3: note: Value stored to 's' is never read
  122 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
