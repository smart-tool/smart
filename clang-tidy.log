source/algos/ac.c:70:13: warning: The right operand of '-' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   70 |     j += (i - kmpNext[i]);
      |             ^ ~~~~~~~~~~
source/algos/ac.c:49:3: note: Calling 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/ac.c:32:10: note: Assuming 'i' is >= 'm'
   32 |   while (i < m) {
      |          ^~~~~
source/algos/ac.c:32:3: note: Loop condition is false. Execution continues on line 32
   32 |   while (i < m) {
      |   ^
source/algos/ac.c:49:3: note: Returning from 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/ac.c:50:8: note: The value 1 is assigned to 'ell'
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |        ^~~~~~~
source/algos/ac.c:50:17: note: 'ell' is >= 'm'
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |                 ^~~
source/algos/ac.c:50:25: note: Left side of '&&' is false
   50 |   for (ell = 1; ell < m && x[ell - 1] == x[ell]; ell++)
      |                         ^
source/algos/ac.c:52:7: note: 'ell' is not equal to 'm'
   52 |   if (ell == m)
      |       ^~~
source/algos/ac.c:52:3: note: Taking false branch
   52 |   if (ell == m)
      |   ^
source/algos/ac.c:54:3: note: Assuming 'pre_time' is null
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/ac.c:54:3: note: Taking false branch
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/ac.c:59:3: note: The value 1 is assigned to 'i'
   59 |   i = ell;
      |   ^~~~~~~
source/algos/ac.c:61:10: note: Assuming the condition is true
   61 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/ac.c:61:3: note: Loop condition is true.  Entering loop body
   61 |   while (j <= n - m) {
      |   ^
source/algos/ac.c:62:12: note: 'i' is >= 'm'
   62 |     while (i < m && x[i] == y[i + j])
      |            ^
source/algos/ac.c:62:18: note: Left side of '&&' is false
   62 |     while (i < m && x[i] == y[i + j])
      |                  ^
source/algos/ac.c:64:9: note: 'i' is >= 'm'
   64 |     if (i >= m) {
      |         ^
source/algos/ac.c:64:5: note: Taking true branch
   64 |     if (i >= m) {
      |     ^
source/algos/ac.c:65:14: note: 'k' is < 'ell'
   65 |       while (k < ell && x[k] == y[j + k])
      |              ^
source/algos/ac.c:65:14: note: Left side of '&&' is true
source/algos/ac.c:65:25: note: Assuming the condition is false
   65 |       while (k < ell && x[k] == y[j + k])
      |                         ^~~~~~~~~~~~~~~~
source/algos/ac.c:65:7: note: Loop condition is false. Execution continues on line 67
   65 |       while (k < ell && x[k] == y[j + k])
      |       ^
source/algos/ac.c:67:11: note: 'k' is < 'ell'
   67 |       if (k >= ell)
      |           ^
source/algos/ac.c:67:7: note: Taking false branch
   67 |       if (k >= ell)
      |       ^
source/algos/ac.c:70:13: note: The right operand of '-' is a garbage value
   70 |     j += (i - kmpNext[i]);
      |             ^ ~~~~~~~~~~
source/algos/ag.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/ag.c:75:3: note: Calling 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/ag.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/ag.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/ag.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/ag.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/ag.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/ag.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/ag.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/ag.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/ag.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/ag.c:77:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   77 |   memset(skip, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/ag.c:77:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   77 |   memset(skip, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/ag.c:111:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
  111 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/ag.c:75:3: note: Calling 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/ag.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/ag.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/ag.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/ag.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/ag.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/ag.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/ag.c:75:3: note: Returning from 'preBmGsAG'
   75 |   preBmGsAG(x, m, bmGs, suff);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ag.c:78:3: note: Assuming 'pre_time' is null
   78 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/ag.c:78:3: note: Taking false branch
   78 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/ag.c:84:10: note: Assuming the condition is true
   84 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/ag.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   while (j <= n - m) {
      |   ^
source/algos/ag.c:86:12: note: 'i' is < 0
   86 |     while (i >= 0) {
      |            ^
source/algos/ag.c:86:5: note: Loop condition is false. Execution continues on line 108
   86 |     while (i >= 0) {
      |     ^
source/algos/ag.c:108:9: note: 'i' is < 0
  108 |     if (i < 0) {
      |         ^
source/algos/ag.c:108:5: note: Taking true branch
  108 |     if (i < 0) {
      |     ^
source/algos/ag.c:111:13: note: Assigned value is garbage or undefined
  111 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/ag.c:117:5: warning: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  117 |     memmove(skip, skip + shift, (m - shift) * sizeof(int));
      |     ^~~~~~~
source/algos/ag.c:117:5: note: Call to function 'memmove' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memmove_s' in case of C11
  117 |     memmove(skip, skip + shift, (m - shift) * sizeof(int));
      |     ^~~~~~~
source/algos/ag.c:118:5: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  118 |     memset(skip + m - shift, 0, shift * sizeof(int));
      |     ^~~~~~
source/algos/ag.c:118:5: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  118 |     memset(skip + m - shift, 0, shift * sizeof(int));
      |     ^~~~~~
source/algos/akc.c:106:26: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
  106 |     c = (unsigned char *)malloc(m * sizeof(char));
      |          ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:106:26: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
  106 |     c = (unsigned char *)malloc(m * sizeof(char));
      |          ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:115:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  115 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:115:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  115 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:173:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  173 |   memset(last, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:173:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  173 |   memset(last, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:200:26: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
  200 |     c = (unsigned char *)malloc(m * sizeof(char));
      |          ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:200:26: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
  200 |     c = (unsigned char *)malloc(m * sizeof(char));
      |          ~~~~~~~~~~~~~~~ ^~~~~~     ~~~~~~~~~~~~
source/algos/akc.c:220:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  220 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:220:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  220 |   memset(link, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:231:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  231 |   memset(cptr, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:231:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  231 |   memset(cptr, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:245:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  245 |   memset(owner, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:245:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  245 |   memset(owner, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/akc.c:300:14: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
  300 |       len[p] = skip[j];
      |              ^
source/algos/akc.c:376:7: note: Assuming 'm' is <= M_CUTOFF
  376 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/akc.c:376:3: note: Taking false branch
  376 |   if (m > M_CUTOFF) {
      |   ^
source/algos/akc.c:399:3: note: Assuming 'pre_time' is null
  399 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/akc.c:399:3: note: Taking false branch
  399 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/akc.c:407:10: note: Assuming the condition is true
  407 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/akc.c:407:3: note: Loop condition is true.  Entering loop body
  407 |   while (j <= n - m) {
      |   ^
source/algos/akc.c:411:5: note: Loop condition is true.  Entering loop body
  411 |     while (i >= 0) {
      |     ^
source/algos/akc.c:412:11: note: 'k' is not equal to 0
  412 |       if (k == 0) {
      |           ^
source/algos/akc.c:412:7: note: Taking false branch
  412 |       if (k == 0) {
      |       ^
source/algos/akc.c:420:11: note: Assuming the condition is false
  420 |       if (x[i] == y[i + j]) {
      |           ^~~~~~~~~~~~~~~~
source/algos/akc.c:420:7: note: Taking false branch
  420 |       if (x[i] == y[i + j]) {
      |       ^
source/algos/akc.c:424:9: note:  Execution continues on line 426
  424 |         break;
      |         ^
source/algos/akc.c:426:9: note: 'i' is >= 0
  426 |     if (i < 0) {
      |         ^
source/algos/akc.c:426:5: note: Taking false branch
  426 |     if (i < 0) {
      |     ^
source/algos/akc.c:432:19: note: '?' condition is false
  432 |       skip[ell] = MAX(0, k - 1);
      |                   ^
source/algos/akc.c:29:20: note: expanded from macro 'MAX'
   29 | #define MAX(a, b) ((a) > (b) ? (a) : (b))
      |                    ^
source/algos/akc.c:436:7: note: Taking true branch
  436 |       if (i == m - 1) {
      |       ^
source/algos/akc.c:444:7: note: Calling 'validateShift'
  444 |       validateShift(m, clink, slink, ell, skip);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/akc.c:276:7: note: 'm' is <= M_CUTOFF
  276 |   if (m > M_CUTOFF) {
      |       ^
source/algos/akc.c:276:3: note: Taking false branch
  276 |   if (m > M_CUTOFF) {
      |   ^
source/algos/akc.c:285:7: note: Assuming the condition is true
  285 |   if (skip[ell] < m) {
      |       ^~~~~~~~~~~~~
source/algos/akc.c:285:3: note: Taking true branch
  285 |   if (skip[ell] < m) {
      |   ^
source/algos/akc.c:290:9: note: Assuming the condition is false
  290 |     if (skip[ell] + k >= m)
      |         ^~~~~~~~~~~~~~~~~~
source/algos/akc.c:290:5: note: Taking false branch
  290 |     if (skip[ell] + k >= m)
      |     ^
source/algos/akc.c:294:9: note: Assuming the condition is false
  294 |     if (skip[ell] + k >= m)
      |         ^~~~~~~~~~~~~~~~~~
source/algos/akc.c:294:5: note: Taking false branch
  294 |     if (skip[ell] + k >= m)
      |     ^
source/algos/akc.c:297:5: note: Loop condition is true.  Entering loop body
  297 |     while (skip[ell] + k < m) {
      |     ^
source/algos/akc.c:298:7: note: The value 3 is assigned to 'j'
  298 |       j = (j + z - 1) % z;
      |       ^~~~~~~~~~~~~~~~~~~
source/algos/akc.c:300:14: note: Assigned value is garbage or undefined
  300 |       len[p] = skip[j];
      |              ^ ~~~~~~~
source/algos/akc.c:433:23: warning: The result of the '' expression is undefined [clang-analyzer-core.UndefinedBinaryOperatorResult]
  433 |       ell = (ell + 1) % M;
      |             ~~~~~~~~~~^~~
source/algos/akc.c:376:7: note: Assuming 'm' is <= M_CUTOFF
  376 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/akc.c:376:3: note: Taking false branch
  376 |   if (m > M_CUTOFF) {
      |   ^
source/algos/akc.c:399:3: note: Assuming 'pre_time' is null
  399 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/akc.c:399:3: note: Taking false branch
  399 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/akc.c:407:10: note: Assuming the condition is true
  407 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/akc.c:407:3: note: Loop condition is true.  Entering loop body
  407 |   while (j <= n - m) {
      |   ^
source/algos/akc.c:411:12: note: Assuming 'i' is >= 0
  411 |     while (i >= 0) {
      |            ^~~~~~
source/algos/akc.c:411:5: note: Loop condition is true.  Entering loop body
  411 |     while (i >= 0) {
      |     ^
source/algos/akc.c:412:11: note: 'k' is not equal to 0
  412 |       if (k == 0) {
      |           ^
source/algos/akc.c:412:7: note: Taking false branch
  412 |       if (k == 0) {
      |       ^
source/algos/akc.c:420:11: note: Assuming the condition is false
  420 |       if (x[i] == y[i + j]) {
      |           ^~~~~~~~~~~~~~~~
source/algos/akc.c:420:7: note: Taking false branch
  420 |       if (x[i] == y[i + j]) {
      |       ^
source/algos/akc.c:424:9: note:  Execution continues on line 426
  424 |         break;
      |         ^
source/algos/akc.c:426:9: note: 'i' is >= 0
  426 |     if (i < 0) {
      |         ^
source/algos/akc.c:426:5: note: Taking false branch
  426 |     if (i < 0) {
      |     ^
source/algos/akc.c:432:19: note: '?' condition is false
  432 |       skip[ell] = MAX(0, k - 1);
      |                   ^
source/algos/akc.c:29:20: note: expanded from macro 'MAX'
   29 | #define MAX(a, b) ((a) > (b) ? (a) : (b))
      |                    ^
source/algos/akc.c:433:23: note: The result of the '' expression is undefined
  433 |       ell = (ell + 1) % M;
      |             ~~~~~~~~~~^~~
source/algos/askip.c:72:14: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   72 |   cell->next = z[node];
      |              ^
source/algos/askip.c:108:9: note: Assuming the condition is false
  108 |   ell = LOG2(m);
      |         ^
source/algos/include/log2.h:45:23: note: expanded from macro 'LOG2'
   45 | #define LOG2(x) (31 - FIRSTBIT(x))
      |                       ^~~~~~~~~~~
source/algos/include/log2.h:42:4: note: expanded from macro 'FIRSTBIT'
   42 |   ((x)&MSK1616                                                                 \
      |    ^~~~~~~~~~~
source/algos/askip.c:108:9: note: '?' condition is false
  108 |   ell = LOG2(m);
      |         ^
source/algos/include/log2.h:45:23: note: expanded from macro 'LOG2'
   45 | #define LOG2(x) (31 - FIRSTBIT(x))
      |                       ^
source/algos/include/log2.h:42:4: note: expanded from macro 'FIRSTBIT'
   42 |   ((x)&MSK1616                                                                 \
      |    ^
source/algos/askip.c:108:9: note: Assuming the condition is false
  108 |   ell = LOG2(m);
      |         ^
source/algos/include/log2.h:45:23: note: expanded from macro 'LOG2'
   45 | #define LOG2(x) (31 - FIRSTBIT(x))
      |                       ^~~~~~~~~~~
source/algos/include/log2.h:44:11: note: expanded from macro 'FIRSTBIT'
   44 |        : ((x)&MSK0808 ? 16 + leftbit[(x) >> 8] : 24 + leftbit[x]))
      |           ^~~~~~~~~~~
source/algos/askip.c:108:9: note: '?' condition is false
  108 |   ell = LOG2(m);
      |         ^
source/algos/include/log2.h:45:23: note: expanded from macro 'LOG2'
   45 | #define LOG2(x) (31 - FIRSTBIT(x))
      |                       ^
source/algos/include/log2.h:44:11: note: expanded from macro 'FIRSTBIT'
   44 |        : ((x)&MSK0808 ? 16 + leftbit[(x) >> 8] : 24 + leftbit[x]))
      |           ^
source/algos/askip.c:109:7: note: Assuming 'ell' is < 1
  109 |   if (ell < 1)
      |       ^~~~~~~
source/algos/askip.c:109:3: note: Taking true branch
  109 |   if (ell < 1)
      |   ^
source/algos/askip.c:114:7: note: Assuming 'size' is <= S_CUTOFF
  114 |   if (size > S_CUTOFF) {
      |       ^~~~~~~~~~~~~~~
source/algos/askip.c:114:3: note: Taking false branch
  114 |   if (size > S_CUTOFF) {
      |   ^
source/algos/askip.c:133:10: note: Calling 'addNode'
  133 |   node = addNode(automaton, art, node, x[0]);
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/askip.c:79:3: note: The value 2 is assigned to 'childNode'
   79 |   childNode = automaton->nodeCounter++;
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/askip.c:82:7: note: 'suffixNode' is equal to 'art'
   82 |   if (suffixNode == art)
      |       ^~~~~~~~~~
source/algos/askip.c:82:3: note: Taking true branch
   82 |   if (suffixNode == art)
      |   ^
source/algos/askip.c:90:3: note: Returning the value 2 (loaded from 'childNode')
   90 |   return (childNode);
      |   ^~~~~~~~~~~~~~~~~~
source/algos/askip.c:133:10: note: Returning from 'addNode'
  133 |   node = addNode(automaton, art, node, x[0]);
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/askip.c:133:3: note: The value 2 is assigned to 'node'
  133 |   node = addNode(automaton, art, node, x[0]);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/askip.c:135:3: note: Loop condition is false. Execution continues on line 137
  135 |   for (i = 1; i < ell; ++i)
      |   ^
source/algos/askip.c:138:11: note: Passing the value 2 via 2nd parameter 'node'
  138 |   setZ(z, node, pos);
      |           ^~~~
source/algos/askip.c:138:3: note: Calling 'setZ'
  138 |   setZ(z, node, pos);
      |   ^~~~~~~~~~~~~~~~~~
source/algos/askip.c:72:14: note: Assigned value is garbage or undefined
   72 |   cell->next = z[node];
      |              ^ ~~~~~~~
source/algos/askip.c:162:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  162 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/askip.c:162:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
  162 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/aut.c:37:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   37 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/aut.c:37:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   37 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/blim.c:54:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   54 |   memset(M, 0xff, sizeof(unsigned long) * SIGMA * wsize);
      |   ^~~~~~
source/algos/blim.c:54:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   54 |   memset(M, 0xff, sizeof(unsigned long) * SIGMA * wsize);
      |   ^~~~~~
source/algos/bm.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/bm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/bm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/bm.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/bm.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/bm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/bm.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/bm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/bm.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/bm.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/bm.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/bm.c:87:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   87 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/bm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/bm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/bm.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/bm.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/bm.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/bm.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/bm.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/bm.c:74:3: note: Returning from 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/bm.c:76:3: note: Assuming 'pre_time' is null
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/bm.c:76:3: note: Taking false branch
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/bm.c:82:10: note: Assuming the condition is true
   82 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/bm.c:82:3: note: Loop condition is true.  Entering loop body
   82 |   while (j <= n - m) {
      |   ^
source/algos/bm.c:83:21: note: 'i' is < 0
   83 |     for (i = m - 1; i >= 0 && x[i] == y[i + j]; --i)
      |                     ^
source/algos/bm.c:83:28: note: Left side of '&&' is false
   83 |     for (i = m - 1; i >= 0 && x[i] == y[i + j]; --i)
      |                            ^
source/algos/bm.c:85:9: note: 'i' is < 0
   85 |     if (i < 0) {
      |         ^
source/algos/bm.c:85:5: note: Taking true branch
   85 |     if (i < 0) {
      |     ^
source/algos/bm.c:87:9: note: Assigned value is garbage or undefined
   87 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/bndm.c:90:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   90 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bndm.c:90:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   90 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bom.c:93:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   93 |   memset(L, 0, (m + 1) * sizeof(List));
      |   ^~~~~~
source/algos/bom.c:93:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   93 |   memset(L, 0, (m + 1) * sizeof(List));
      |   ^~~~~~
source/algos/bom.c:94:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   94 |   memset(T, FALSE, (m + 1) * sizeof(char));
      |   ^~~~~~
source/algos/bom.c:94:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   94 |   memset(T, FALSE, (m + 1) * sizeof(char));
      |   ^~~~~~
source/algos/bom2.c:58:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   58 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/bom2.c:41:7: note: Assuming the condition is false
   41 |   if (m + 2 > M_CUTOFF) {
      |       ^~~~~~~~~~~~~~~~
source/algos/bom2.c:41:3: note: Taking false branch
   41 |   if (m + 2 > M_CUTOFF) {
      |   ^
source/algos/bom2.c:46:17: note: Assuming the condition is false
   46 |     for (i = 0; i <= m + 1; i++)
      |                 ^~~~~~~~~~
source/algos/bom2.c:46:5: note: Loop condition is false. Execution continues on line 51
   46 |     for (i = 0; i <= m + 1; i++)
      |     ^
source/algos/bom2.c:51:3: note: Loop condition is false. Execution continues on line 54
   51 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/bom2.c:55:8: note: Value assigned to 'i'
   55 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/bom2.c:55:15: note: Assuming 'i' is > 0
   55 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/bom2.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/bom2.c:58:17: note: Array access results in an undefined pointer dereference
   58 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/bww.c:42:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   42 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:42:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   42 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:51:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   51 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:51:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   51 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:123:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  123 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:123:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  123 |   memset(B, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:132:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  132 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/bww.c:132:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  132 |   memset(C, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:49:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   49 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:49:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   49 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:55:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   55 |   memset(rmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:55:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   55 |   memset(rmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/colussi.c:57:21: warning: The left operand of '==' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   57 |     if (hmax[i + 1] == m)
      |                     ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking true branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is < 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:19: note: Assuming 'i' is >= 0
   56 |   for (i = m - 1; i >= 0; --i) {
      |                   ^~~~~~
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:21: note: The left operand of '==' is a garbage value due to array index out of bounds
   57 |     if (hmax[i + 1] == m)
      |         ~~~~~~~~~~~ ^
source/algos/colussi.c:94:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   94 |     next[i] = nhd0[m - rmin[h[i]]];
      |             ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is true
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is true.  Entering loop body
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking false branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is >= 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is true.  Entering loop body
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:51:5: note: Taking false branch
   51 |     if (hmax[i] < m)
      |     ^
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:5: note: Taking false branch
   57 |     if (hmax[i + 1] == m)
      |     ^
source/algos/colussi.c:59:9: note: Assuming the condition is true
   59 |     if (kmin[i] == 0)
      |         ^~~~~~~~~~~~
source/algos/colussi.c:59:5: note: Taking true branch
   59 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:56:3: note: Loop condition is false. Execution continues on line 66
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:68:3: note: Loop condition is true.  Entering loop body
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:69:5: note: Taking true branch
   69 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:68:3: note: Loop condition is false. Execution continues on line 73
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is false. Execution continues on line 78
   76 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:78:3: note: Loop condition is true.  Entering loop body
   78 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:78:3: note: Loop condition is false. Execution continues on line 80
source/algos/colussi.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:86:5: note: Taking false branch
   86 |     if (kmin[i] > 0)
      |     ^
source/algos/colussi.c:84:3: note: Loop condition is false. Execution continues on line 91
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is false. Execution continues on line 93
   91 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:93:3: note: Loop condition is true.  Entering loop body
   93 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:94:13: note: Assigned value is garbage or undefined
   94 |     next[i] = nhd0[m - rmin[h[i]]];
      |             ^ ~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:95:11: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   95 |   next[m] = nhd0[m - rmin[h[m - 1]]];
      |           ^
source/algos/colussi.c:106:8: note: Calling 'preColussi'
  106 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/colussi.c:35:12: note: Assuming the condition is false
   35 |     while (x[i] == x[i - k])
      |            ^~~~~~~~~~~~~~~~
source/algos/colussi.c:35:5: note: Loop condition is false. Execution continues on line 37
   35 |     while (x[i] == x[i - k])
      |     ^
source/algos/colussi.c:39:5: note: Loop condition is false. Execution continues on line 43
   39 |     while (hmax[q - k] + k < i) {
      |     ^
source/algos/colussi.c:44:5: note: Taking true branch
   44 |     if (k == i + 1)
      |     ^
source/algos/colussi.c:46:12: note: Assuming 'k' is > 'm'
   46 |   } while (k <= m);
      |            ^~~~~~
source/algos/colussi.c:34:3: note: Loop condition is false.  Exiting loop
   34 |   do {
      |   ^
source/algos/colussi.c:50:15: note: Assuming 'i' is >= 1
   50 |   for (i = m; i >= 1; --i)
      |               ^~~~~~
source/algos/colussi.c:50:3: note: Loop condition is true.  Entering loop body
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:51:5: note: Taking false branch
   51 |     if (hmax[i] < m)
      |     ^
source/algos/colussi.c:50:3: note: Loop condition is false. Execution continues on line 55
   50 |   for (i = m; i >= 1; --i)
      |   ^
source/algos/colussi.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:57:5: note: Taking true branch
   57 |     if (hmax[i + 1] == m)
      |     ^
source/algos/colussi.c:59:9: note: Assuming the condition is false
   59 |     if (kmin[i] == 0)
      |         ^~~~~~~~~~~~
source/algos/colussi.c:59:5: note: Taking false branch
   59 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:56:3: note: Loop condition is false. Execution continues on line 66
   56 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/colussi.c:68:3: note: Loop condition is true.  Entering loop body
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:69:5: note: Taking false branch
   69 |     if (kmin[i] == 0)
      |     ^
source/algos/colussi.c:68:3: note: Loop condition is false. Execution continues on line 73
   68 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is true.  Entering loop body
   76 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:76:3: note: Loop condition is false. Execution continues on line 78
source/algos/colussi.c:78:3: note: Loop condition is false. Execution continues on line 80
   78 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:84:3: note: Loop condition is true.  Entering loop body
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:86:9: note: Assuming the condition is false
   86 |     if (kmin[i] > 0)
      |         ^~~~~~~~~~~
source/algos/colussi.c:86:5: note: Taking false branch
   86 |     if (kmin[i] > 0)
      |     ^
source/algos/colussi.c:84:3: note: Loop condition is false. Execution continues on line 91
   84 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is true.  Entering loop body
   91 |   for (i = 0; i <= nd; ++i)
      |   ^
source/algos/colussi.c:91:3: note: Loop condition is false. Execution continues on line 93
source/algos/colussi.c:93:3: note: Loop condition is false. Execution continues on line 95
   93 |   for (i = nd + 1; i < m; ++i)
      |   ^
source/algos/colussi.c:95:11: note: Assigned value is garbage or undefined
   95 |   next[m] = nhd0[m - rmin[h[m - 1]]];
      |           ^ ~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/dfdm.c:51:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   51 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/dfdm.c:51:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   51 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/dfdm.c:69:32: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   69 |         ell = getLength(state) + 1;
      |                                ^
source/algos/dfdm.c:40:7: note: Assuming 'm' is <= M_CUTOFF
   40 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/dfdm.c:40:3: note: Taking false branch
   40 |   if (m > M_CUTOFF) {
      |   ^
source/algos/dfdm.c:52:3: note: Calling 'buildSimpleSuffixAutomaton'
   52 |   buildSimpleSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/include/AUTOMATON.h:164:15: note: Assuming 'i' is >= 'm'
  164 |   for (i = 0; i < m; ++i) {
      |               ^~~~~
source/algos/include/AUTOMATON.h:164:3: note: Loop condition is false. Execution continues on line 194
  164 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/include/AUTOMATON.h:195:3: note: Loop condition is false. Execution continues on line 195
  195 |   while (last != init) {
      |   ^
source/algos/include/AUTOMATON.h:199:1: note: Returning without writing to '*tlength'
  199 | }
      | ^
source/algos/dfdm.c:52:3: note: Returning from 'buildSimpleSuffixAutomaton'
   52 |   buildSimpleSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/dfdm.c:53:3: note: The value 0 is assigned to 'init'
   53 |   init = 0;
      |   ^~~~~~~~
source/algos/dfdm.c:54:3: note: Assuming 'pre_time' is null
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/dfdm.c:54:3: note: Taking false branch
   54 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/dfdm.c:60:3: note: The value 0 is assigned to 'state'
   60 |   state = init;
      |   ^~~~~~~~~~~~
source/algos/dfdm.c:61:15: note: Assuming 'j' is < 'n'
   61 |   for (j = 0; j < n; ++j) {
      |               ^~~~~
source/algos/dfdm.c:61:3: note: Loop condition is true.  Entering loop body
   61 |   for (j = 0; j < n; ++j) {
      |   ^
source/algos/dfdm.c:62:9: note: Assuming the condition is false
   62 |     if (getTarget(state, y[j]) != UNDEFINED) {
      |         ^
source/algos/include/AUTOMATON.h:22:25: note: expanded from macro 'getTarget'
   22 | #define getTarget(p, c) ttrans[(p)*SIGMA + (c)]
      |                         ^
source/algos/dfdm.c:62:5: note: Taking false branch
   62 |     if (getTarget(state, y[j]) != UNDEFINED) {
      |     ^
source/algos/dfdm.c:66:14: note: 'state' is equal to 'init'
   66 |       while (state != init && getTarget(state, y[j]) == UNDEFINED)
      |              ^~~~~
source/algos/dfdm.c:66:28: note: Left side of '&&' is false
   66 |       while (state != init && getTarget(state, y[j]) == UNDEFINED)
      |                            ^
source/algos/dfdm.c:68:11: note: Assuming the condition is true
   68 |       if (getTarget(state, y[j]) != UNDEFINED) {
      |           ^
source/algos/include/AUTOMATON.h:22:25: note: expanded from macro 'getTarget'
   22 | #define getTarget(p, c) ttrans[(p)*SIGMA + (c)]
      |                         ^
source/algos/dfdm.c:68:7: note: Taking true branch
   68 |       if (getTarget(state, y[j]) != UNDEFINED) {
      |       ^
source/algos/dfdm.c:69:32: note: The left operand of '+' is a garbage value
   69 |         ell = getLength(state) + 1;
      |                                ^
source/algos/ebom.c:61:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   61 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/ebom.c:40:7: note: Assuming 'm' is >= 2
   40 |   if (m < 2)
      |       ^~~~~
source/algos/ebom.c:40:3: note: Taking false branch
   40 |   if (m < 2)
      |   ^
source/algos/ebom.c:46:7: note: Assuming the condition is false
   46 |   if (m + 2 > M_CUTOFF) {
      |       ^~~~~~~~~~~~~~~~
source/algos/ebom.c:46:3: note: Taking false branch
   46 |   if (m + 2 > M_CUTOFF) {
      |   ^
source/algos/ebom.c:51:17: note: Assuming the condition is false
   51 |     for (i = 0; i <= m + 1; i++)
      |                 ^~~~~~~~~~
source/algos/ebom.c:51:5: note: Loop condition is false. Execution continues on line 54
   51 |     for (i = 0; i <= m + 1; i++)
      |     ^
source/algos/ebom.c:54:3: note: Loop condition is false. Execution continues on line 57
   54 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/ebom.c:58:8: note: The value 2147483647 is assigned to 'i'
   58 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/ebom.c:58:3: note: Loop condition is true.  Entering loop body
   58 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/ebom.c:61:17: note: Array access results in an undefined pointer dereference
   61 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/epsm.c:253:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  253 |   memset(flist, 0, sizeof(LIST *) * 2048);
      |   ^~~~~~
source/algos/epsm.c:253:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  253 |   memset(flist, 0, sizeof(LIST *) * 2048);
      |   ^~~~~~
source/algos/epsm.c:255:39: warning: Potential memory leak [clang-analyzer-unix.Malloc]
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |                                       ^
source/algos/epsm.c:355:7: note: Assuming 'patlen' is >= 2
  355 |   if (patlen < 2)
      |       ^~~~~~~~~~
source/algos/epsm.c:355:3: note: Taking false branch
  355 |   if (patlen < 2)
      |   ^
source/algos/epsm.c:357:7: note: Assuming 'patlen' is not equal to 2
  357 |   if (patlen == 2)
      |       ^~~~~~~~~~~
source/algos/epsm.c:357:3: note: Taking false branch
  357 |   if (patlen == 2)
      |   ^
source/algos/epsm.c:359:7: note: Assuming 'patlen' is not equal to 3
  359 |   if (patlen == 3)
      |       ^~~~~~~~~~~
source/algos/epsm.c:359:3: note: Taking false branch
  359 |   if (patlen == 3)
      |   ^
source/algos/epsm.c:361:7: note: Assuming 'patlen' is not equal to 4
  361 |   if (patlen == 4)
      |       ^~~~~~~~~~~
source/algos/epsm.c:361:3: note: Taking false branch
  361 |   if (patlen == 4)
      |   ^
source/algos/epsm.c:363:7: note: Assuming 'patlen' is >= 16
  363 |   if (patlen >= 16)
      |       ^~~~~~~~~~~~
source/algos/epsm.c:363:3: note: Taking true branch
  363 |   if (patlen >= 16)
      |   ^
source/algos/epsm.c:364:12: note: Calling 'search16'
  364 |     return search16(pattern, patlen, x, textlen);
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:255:15: note: Assuming the condition is true
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |               ^~~~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:255:3: note: Loop condition is true.  Entering loop body
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |   ^
source/algos/epsm.c:261:9: note: Assuming the condition is true
  261 |     if (flist[filter] == 0) {
      |         ^~~~~~~~~~~~~~~~~~
source/algos/epsm.c:261:5: note: Taking true branch
  261 |     if (flist[filter] == 0) {
      |     ^
source/algos/epsm.c:262:31: note: Memory is allocated
  262 |       flist[filter] = (LIST *)malloc(sizeof(LIST));
      |                               ^~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:263:11: note: Assuming the condition is true
  263 |       if (flist[filter]) {
      |           ^~~~~~~~~~~~~
source/algos/epsm.c:263:7: note: Taking true branch
  263 |       if (flist[filter]) {
      |       ^
source/algos/epsm.c:255:15: note: Assuming the condition is true
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |               ^~~~~~~~~~~~~~~~~~~~~~
source/algos/epsm.c:255:3: note: Loop condition is true.  Entering loop body
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |   ^
source/algos/epsm.c:261:9: note: Assuming the condition is true
  261 |     if (flist[filter] == 0) {
      |         ^~~~~~~~~~~~~~~~~~
source/algos/epsm.c:261:5: note: Taking true branch
  261 |     if (flist[filter] == 0) {
      |     ^
source/algos/epsm.c:263:11: note: Assuming the condition is false
  263 |       if (flist[filter]) {
      |           ^~~~~~~~~~~~~
source/algos/epsm.c:263:7: note: Taking false branch
  263 |       if (flist[filter]) {
      |       ^
source/algos/epsm.c:255:39: note: Potential memory leak
  255 |   for (i = 1; (int)i < tmppatlen - 7; i++) {
      |                                       ^
source/algos/fbom.c:56:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   56 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/fbom.c:41:7: note: Assuming the condition is false
   41 |   if (m + 2 > M_CUTOFF) {
      |       ^~~~~~~~~~~~~~~~
source/algos/fbom.c:41:3: note: Taking false branch
   41 |   if (m + 2 > M_CUTOFF) {
      |   ^
source/algos/fbom.c:46:17: note: Assuming the condition is false
   46 |     for (i = 0; i <= m + 1; i++)
      |                 ^~~~~~~~~~
source/algos/fbom.c:46:5: note: Loop condition is false. Execution continues on line 49
   46 |     for (i = 0; i <= m + 1; i++)
      |     ^
source/algos/fbom.c:49:3: note: Loop condition is false. Execution continues on line 52
   49 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/fbom.c:53:8: note: Value assigned to 'i'
   53 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/fbom.c:53:15: note: Assuming 'i' is > 0
   53 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/fbom.c:53:3: note: Loop condition is true.  Entering loop body
   53 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/fbom.c:56:17: note: Array access results in an undefined pointer dereference
   56 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/fdm.c:50:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   50 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/fdm.c:50:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   50 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/fdm.c:68:32: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   68 |         ell = getLength(state) + 1;
      |                                ^
source/algos/fdm.c:39:7: note: Assuming 'm' is <= M_CUTOFF
   39 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/fdm.c:39:3: note: Taking false branch
   39 |   if (m > M_CUTOFF) {
      |   ^
source/algos/fdm.c:51:3: note: Calling 'buildSimpleSuffixAutomaton'
   51 |   buildSimpleSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/include/AUTOMATON.h:164:15: note: Assuming 'i' is >= 'm'
  164 |   for (i = 0; i < m; ++i) {
      |               ^~~~~
source/algos/include/AUTOMATON.h:164:3: note: Loop condition is false. Execution continues on line 194
  164 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/include/AUTOMATON.h:195:3: note: Loop condition is false. Execution continues on line 195
  195 |   while (last != init) {
      |   ^
source/algos/include/AUTOMATON.h:199:1: note: Returning without writing to '*tlength'
  199 | }
      | ^
source/algos/fdm.c:51:3: note: Returning from 'buildSimpleSuffixAutomaton'
   51 |   buildSimpleSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/fdm.c:52:3: note: The value 0 is assigned to 'init'
   52 |   init = 0;
      |   ^~~~~~~~
source/algos/fdm.c:55:3: note: Assuming 'pre_time' is null
   55 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/fdm.c:55:3: note: Taking false branch
   55 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/fdm.c:59:3: note: The value 0 is assigned to 'state'
   59 |   state = init;
      |   ^~~~~~~~~~~~
source/algos/fdm.c:60:15: note: Assuming 'j' is < 'n'
   60 |   for (j = 0; j < n; ++j) {
      |               ^~~~~
source/algos/fdm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (j = 0; j < n; ++j) {
      |   ^
source/algos/fdm.c:61:9: note: Assuming the condition is false
   61 |     if (getTarget(state, y[j]) != UNDEFINED) {
      |         ^
source/algos/include/AUTOMATON.h:22:25: note: expanded from macro 'getTarget'
   22 | #define getTarget(p, c) ttrans[(p)*SIGMA + (c)]
      |                         ^
source/algos/fdm.c:61:5: note: Taking false branch
   61 |     if (getTarget(state, y[j]) != UNDEFINED) {
      |     ^
source/algos/fdm.c:65:14: note: 'state' is equal to 'init'
   65 |       while (state != init && getTarget(state, y[j]) == UNDEFINED)
      |              ^~~~~
source/algos/fdm.c:65:28: note: Left side of '&&' is false
   65 |       while (state != init && getTarget(state, y[j]) == UNDEFINED)
      |                            ^
source/algos/fdm.c:67:11: note: Assuming the condition is true
   67 |       if (getTarget(state, y[j]) != UNDEFINED) {
      |           ^
source/algos/include/AUTOMATON.h:22:25: note: expanded from macro 'getTarget'
   22 | #define getTarget(p, c) ttrans[(p)*SIGMA + (c)]
      |                         ^
source/algos/fdm.c:67:7: note: Taking true branch
   67 |       if (getTarget(state, y[j]) != UNDEFINED) {
      |       ^
source/algos/fdm.c:68:32: note: The left operand of '+' is a garbage value
   68 |         ell = getLength(state) + 1;
      |                                ^
source/algos/ffs.c:41:7: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   41 |     i = temx[last];
      |       ^
source/algos/ffs.c:66:3: note: Calling 'Forward_Suffix_Function'
   66 |   Forward_Suffix_Function(x, m, gs, SIGMA);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/ffs.c:34:15: note: Assuming 'i' is >= 'm'
   34 |   for (i = 0; i < m; i++)
      |               ^~~~~
source/algos/ffs.c:34:3: note: Loop condition is false. Execution continues on line 37
   34 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ffs.c:37:15: note: 'i' is >= 'm'
   37 |   for (i = 0; i < m; i++)
      |               ^
source/algos/ffs.c:37:3: note: Loop condition is false. Execution continues on line 39
   37 |   for (i = 0; i < m; i++)
      |   ^
source/algos/ffs.c:39:24: note: Assuming 'suffix_len' is <= 'm'
   39 |   for (suffix_len = 0; suffix_len <= m; suffix_len++) {
      |                        ^~~~~~~~~~~~~~~
source/algos/ffs.c:39:3: note: Loop condition is true.  Entering loop body
   39 |   for (suffix_len = 0; suffix_len <= m; suffix_len++) {
      |   ^
source/algos/ffs.c:40:5: note: The value -1 is assigned to 'last'
   40 |     last = m - 1;
      |     ^~~~~~~~~~~~
source/algos/ffs.c:41:7: note: Assigned value is garbage or undefined
   41 |     i = temx[last];
      |       ^ ~~~~~~~~~~
source/algos/fs-w6.c:108:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
  108 |   s3 = q;
      |   ^    ~
source/algos/fs-w6.c:108:3: note: Value stored to 's3' is never read
  108 |   s3 = q;
      |   ^    ~
source/algos/fs-w6.c:110:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
  110 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w6.c:110:3: note: Value stored to 's5' is never read
  110 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:104:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
  104 |   s3 = q;
      |   ^    ~
source/algos/fs-w8.c:104:3: note: Value stored to 's3' is never read
  104 |   s3 = q;
      |   ^    ~
source/algos/fs-w8.c:106:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
  106 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:106:3: note: Value stored to 's5' is never read
  106 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:108:3: warning: Value stored to 's7' is never read [clang-analyzer-deadcode.DeadStores]
  108 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fs-w8.c:108:3: note: Value stored to 's7' is never read
  108 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:89:3: warning: Value stored to 's3' is never read [clang-analyzer-deadcode.DeadStores]
   89 |   s3 = q;
      |   ^    ~
source/algos/fsbndm-w8.c:89:3: note: Value stored to 's3' is never read
   89 |   s3 = q;
      |   ^    ~
source/algos/fsbndm-w8.c:91:3: warning: Value stored to 's5' is never read [clang-analyzer-deadcode.DeadStores]
   91 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:91:3: note: Value stored to 's5' is never read
   91 |   s5 = 2 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:93:3: warning: Value stored to 's7' is never read [clang-analyzer-deadcode.DeadStores]
   93 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/fsbndm-w8.c:93:3: note: Value stored to 's7' is never read
   93 |   s7 = 3 * q;
      |   ^    ~~~~~
source/algos/gg.c:50:4: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   50 |    memset(kmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:50:4: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   50 |    memset(kmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:56:4: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   56 |    memset(rmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:56:4: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   56 |    memset(rmin, 0, m * sizeof(int));
      |    ^~~~~~
source/algos/gg.c:58:23: warning: The left operand of '==' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
   58 |       if (hmax[i + 1] == m)
      |                       ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking true branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: 'i' is < 1
   51 |    for (i = m; i >= 1; --i)
      |                ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:20: note: Assuming 'i' is >= 0
   57 |    for (i = m - 1; i >= 0; --i) {
      |                    ^~~~~~
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:23: note: The left operand of '==' is a garbage value due to array index out of bounds
   58 |       if (hmax[i + 1] == m)
      |           ~~~~~~~~~~~ ^
source/algos/gg.c:95:15: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   95 |       next[i] = nhd0[m - rmin[h[i]]];
      |               ^
source/algos/gg.c:107:17: note: Assuming the condition is true
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is true.  Entering loop body
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is true
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is true.  Entering loop body
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking false branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: Assuming 'i' is >= 1
   51 |    for (i = m; i >= 1; --i)
      |                ^~~~~~
source/algos/gg.c:51:4: note: Loop condition is true.  Entering loop body
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:52:7: note: Taking false branch
   52 |       if (hmax[i] < m)
      |       ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:7: note: Taking false branch
   58 |       if (hmax[i + 1] == m)
      |       ^
source/algos/gg.c:60:11: note: Assuming the condition is true
   60 |       if (kmin[i] == 0)
      |           ^~~~~~~~~~~~
source/algos/gg.c:60:7: note: Taking true branch
   60 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:57:4: note: Loop condition is false. Execution continues on line 67
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:69:4: note: Loop condition is true.  Entering loop body
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:70:7: note: Taking true branch
   70 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:69:4: note: Loop condition is false. Execution continues on line 74
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is false. Execution continues on line 79
   77 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:79:4: note: Loop condition is true.  Entering loop body
   79 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:79:4: note: Loop condition is false. Execution continues on line 81
source/algos/gg.c:85:4: note: Loop condition is true.  Entering loop body
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:87:7: note: Taking false branch
   87 |       if (kmin[i] > 0)
      |       ^
source/algos/gg.c:85:4: note: Loop condition is false. Execution continues on line 92
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:92:4: note: Loop condition is false. Execution continues on line 94
   92 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:94:4: note: Loop condition is true.  Entering loop body
   94 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:95:15: note: Assigned value is garbage or undefined
   95 |       next[i] = nhd0[m - rmin[h[i]]];
      |               ^ ~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:96:12: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   96 |    next[m] = nhd0[m - rmin[h[m - 1]]];
      |            ^
source/algos/gg.c:107:17: note: Assuming the condition is true
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is true.  Entering loop body
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:107:17: note: Assuming the condition is false
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |                 ^~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:107:3: note: Loop condition is false. Execution continues on line 109
  107 |   for (ell = 0; x[ell] == x[ell + 1]; ell++)
      |   ^
source/algos/gg.c:109:7: note: Assuming the condition is false
  109 |   if (ell == m - 1) {
      |       ^~~~~~~~~~~~
source/algos/gg.c:109:3: note: Taking false branch
  109 |   if (ell == m - 1) {
      |   ^
source/algos/gg.c:125:8: note: Calling 'preColussi'
  125 |   nd = preColussi(x, m, h, next, shift);
      |        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:36:14: note: Assuming the condition is true
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is true.  Entering loop body
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:36:14: note: Assuming the condition is false
   36 |       while (x[i] == x[i - k])
      |              ^~~~~~~~~~~~~~~~
source/algos/gg.c:36:7: note: Loop condition is false. Execution continues on line 38
   36 |       while (x[i] == x[i - k])
      |       ^
source/algos/gg.c:40:7: note: Loop condition is false. Execution continues on line 44
   40 |       while (hmax[q - k] + k < i) {
      |       ^
source/algos/gg.c:45:7: note: Taking false branch
   45 |       if (k == i + 1)
      |       ^
source/algos/gg.c:47:13: note: Assuming 'k' is > 'm'
   47 |    } while (k <= m);
      |             ^~~~~~
source/algos/gg.c:35:4: note: Loop condition is false.  Exiting loop
   35 |    do {
      |    ^
source/algos/gg.c:51:16: note: Assuming 'i' is >= 1
   51 |    for (i = m; i >= 1; --i)
      |                ^~~~~~
source/algos/gg.c:51:4: note: Loop condition is true.  Entering loop body
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:52:7: note: Taking false branch
   52 |       if (hmax[i] < m)
      |       ^
source/algos/gg.c:51:4: note: Loop condition is false. Execution continues on line 56
   51 |    for (i = m; i >= 1; --i)
      |    ^
source/algos/gg.c:57:4: note: Loop condition is true.  Entering loop body
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:58:7: note: Taking false branch
   58 |       if (hmax[i + 1] == m)
      |       ^
source/algos/gg.c:60:11: note: Assuming the condition is false
   60 |       if (kmin[i] == 0)
      |           ^~~~~~~~~~~~
source/algos/gg.c:60:7: note: Taking false branch
   60 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:57:4: note: Loop condition is false. Execution continues on line 67
   57 |    for (i = m - 1; i >= 0; --i) {
      |    ^
source/algos/gg.c:69:4: note: Loop condition is true.  Entering loop body
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:70:7: note: Taking false branch
   70 |       if (kmin[i] == 0)
      |       ^
source/algos/gg.c:69:4: note: Loop condition is false. Execution continues on line 74
   69 |    for (i = 0; i < m; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is true.  Entering loop body
   77 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:77:4: note: Loop condition is false. Execution continues on line 79
source/algos/gg.c:79:4: note: Loop condition is false. Execution continues on line 81
   79 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:85:4: note: Loop condition is true.  Entering loop body
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:87:11: note: Assuming the condition is false
   87 |       if (kmin[i] > 0)
      |           ^~~~~~~~~~~
source/algos/gg.c:87:7: note: Taking false branch
   87 |       if (kmin[i] > 0)
      |       ^
source/algos/gg.c:85:4: note: Loop condition is false. Execution continues on line 92
   85 |    for (i = 0; i < m; ++i) {
      |    ^
source/algos/gg.c:92:4: note: Loop condition is true.  Entering loop body
   92 |    for (i = 0; i <= nd; ++i)
      |    ^
source/algos/gg.c:92:4: note: Loop condition is false. Execution continues on line 94
source/algos/gg.c:94:4: note: Loop condition is false. Execution continues on line 96
   94 |    for (i = nd + 1; i < m; ++i)
      |    ^
source/algos/gg.c:96:12: note: Assigned value is garbage or undefined
   96 |    next[m] = nhd0[m - rmin[h[m - 1]]];
      |            ^ ~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/gg.c:146:11: warning: Value stored to 'heavy' is never read [clang-analyzer-deadcode.DeadStores]
  146 |           heavy = 0;
      |           ^       ~
source/algos/gg.c:146:11: note: Value stored to 'heavy' is never read
  146 |           heavy = 0;
      |           ^       ~
source/algos/hash3.c:63:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   63 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash3.c:63:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   63 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash5.c:70:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   70 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash5.c:70:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   70 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash8.c:80:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   80 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/hash8.c:80:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   80 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/ildm1.c:45:27: warning: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char' [clang-analyzer-unix.MallocSizeof]
   45 |     xR = (unsigned char *)malloc(sizeof(char) * (m + 1));
      |           ~~~~~~~~~~~~~~~ ^~~~~~ ~~~~~~~~~~~~
source/algos/ildm1.c:45:27: note: Result of 'malloc' is converted to a pointer of type 'unsigned char', which is incompatible with sizeof operand type 'char'
   45 |     xR = (unsigned char *)malloc(sizeof(char) * (m + 1));
      |           ~~~~~~~~~~~~~~~ ^~~~~~ ~~~~~~~~~~~~
source/algos/ildm1.c:62:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   62 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:62:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   62 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:65:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   65 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm1.c:65:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   65 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:73:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   73 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:73:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   73 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:75:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   75 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ildm2.c:75:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   75 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/include/AUTOMATON.h:168:31: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
  168 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/dfdm.c:40:7: note: Assuming 'm' is <= M_CUTOFF
   40 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/dfdm.c:40:3: note: Taking false branch
   40 |   if (m > M_CUTOFF) {
      |   ^
source/algos/dfdm.c:52:3: note: Calling 'buildSimpleSuffixAutomaton'
   52 |   buildSimpleSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/include/AUTOMATON.h:159:3: note: The value 0 is assigned to 'init'
  159 |   init = 0;
      |   ^~~~~~~~
source/algos/include/AUTOMATON.h:163:3: note: The value 0 is assigned to 'last'
  163 |   last = init;
      |   ^~~~~~~~~~~
source/algos/include/AUTOMATON.h:164:15: note: Assuming 'i' is < 'm'
  164 |   for (i = 0; i < m; ++i) {
      |               ^~~~~
source/algos/include/AUTOMATON.h:164:3: note: Loop condition is true.  Entering loop body
  164 |   for (i = 0; i < m; ++i) {
      |   ^
source/algos/include/AUTOMATON.h:166:5: note: The value 0 is assigned to 'p'
  166 |     p = last;
      |     ^~~~~~~~
source/algos/include/AUTOMATON.h:168:31: note: The left operand of '+' is a garbage value
  168 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/include/AUTOMATON.h:23:41: note: expanded from macro 'setLength'
   23 | #define setLength(p, q) tlength[(p)] = (q)
      |                                         ^
source/algos/kmp.c:63:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   63 |       i = kmpNext[i];
      |         ^ ~~~~~~~~~~
source/algos/kmp.c:49:3: note: Calling 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmp.c:32:10: note: Assuming 'i' is >= 'm'
   32 |   while (i < m) {
      |          ^~~~~
source/algos/kmp.c:32:3: note: Loop condition is false. Execution continues on line 32
   32 |   while (i < m) {
      |   ^
source/algos/kmp.c:49:3: note: Returning from 'preKmp'
   49 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmp.c:50:3: note: Assuming 'pre_time' is null
   50 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/kmp.c:50:3: note: Taking false branch
   50 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/kmp.c:56:10: note: Assuming 'j' is < 'n'
   56 |   while (j < n) {
      |          ^~~~~
source/algos/kmp.c:56:3: note: Loop condition is true.  Entering loop body
   56 |   while (j < n) {
      |   ^
source/algos/kmp.c:57:12: note: Left side of '&&' is true
   57 |     while (i > -1 && x[i] != y[j])
      |            ^
source/algos/kmp.c:57:22: note: Assuming the condition is false
   57 |     while (i > -1 && x[i] != y[j])
      |                      ^~~~~~~~~~~~
source/algos/kmp.c:57:5: note: Loop condition is false. Execution continues on line 59
   57 |     while (i > -1 && x[i] != y[j])
      |     ^
source/algos/kmp.c:59:5: note: The value 1 is assigned to 'i'
   59 |     i++;
      |     ^~~
source/algos/kmp.c:61:9: note: 'i' is >= 'm'
   61 |     if (i >= m) {
      |         ^
source/algos/kmp.c:61:5: note: Taking true branch
   61 |     if (i >= m) {
      |     ^
source/algos/kmp.c:63:9: note: Assigned value is garbage or undefined
   63 |       i = kmpNext[i];
      |         ^ ~~~~~~~~~~
source/algos/kmpskip.c:74:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   74 |   memset(z, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:74:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   74 |   memset(z, -1, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:75:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   75 |   memset(list, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:75:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   75 |   memset(list, -1, m * sizeof(int));
      |   ^~~~~~
source/algos/kmpskip.c:88:3: warning: Value stored to 'i' is never read [clang-analyzer-deadcode.DeadStores]
   88 |   i = j = -1;
      |   ^   ~~~~~~
source/algos/kmpskip.c:88:3: note: Value stored to 'i' is never read
   88 |   i = j = -1;
      |   ^   ~~~~~~
source/algos/kmpskip.c:136:24: warning: The right operand of '-' is a garbage value due to array index out of bounds [clang-analyzer-core.UndefinedBinaryOperatorResult]
  136 |         kmpStart += (k - mpNext[k]);
      |                        ^ ~~~~~~~~~
source/algos/kmpskip.c:72:3: note: Calling 'preMp'
   72 |   preMp((char*)x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:51:10: note: Assuming 'i' is >= 'm'
   51 |   while (i < m) {
      |          ^~~~~
source/algos/kmpskip.c:51:3: note: Loop condition is false. Execution continues on line 51
   51 |   while (i < m) {
      |   ^
source/algos/kmpskip.c:72:3: note: Returning from 'preMp'
   72 |   preMp((char*)x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:73:3: note: Calling 'preKmp'
   73 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:33:7: note: Assigning -1
   33 |   j = kmpNext[0] = -1;
      |       ^~~~~~~~~~~~~~~
source/algos/kmpskip.c:34:10: note: 'i' is >= 'm'
   34 |   while (i < m) {
      |          ^
source/algos/kmpskip.c:34:3: note: Loop condition is false. Execution continues on line 34
   34 |   while (i < m) {
      |   ^
source/algos/kmpskip.c:73:3: note: Returning from 'preKmp'
   73 |   preKmp(x, m, kmpNext);
      |   ^~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:77:15: note: 'i' is >= 'm'
   77 |   for (i = 1; i < m; ++i) {
      |               ^
source/algos/kmpskip.c:77:3: note: Loop condition is false. Execution continues on line 81
   77 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/kmpskip.c:81:3: note: Assuming 'pre_time' is null
   81 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/kmpskip.c:81:3: note: Taking false branch
   81 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/kmpskip.c:91:12: note: Assuming 'j' is < 'n'
   91 |   } while (j < n && z[y[j]] < 0);
      |            ^~~~~
source/algos/kmpskip.c:91:12: note: Left side of '&&' is true
source/algos/kmpskip.c:89:3: note: Loop condition is false.  Exiting loop
   89 |   do {
      |   ^
source/algos/kmpskip.c:92:7: note: Assuming 'j' is < 'n'
   92 |   if (j >= n) {
      |       ^~~~~~
source/algos/kmpskip.c:92:3: note: Taking false branch
   92 |   if (j >= n) {
      |   ^
source/algos/kmpskip.c:98:10: note: Assuming the condition is true
   98 |   while (start <= n - m) {
      |          ^~~~~~~~~~~~~~
source/algos/kmpskip.c:98:3: note: Loop condition is true.  Entering loop body
   98 |   while (start <= n - m) {
      |   ^
source/algos/kmpskip.c:99:9: note: Assuming 'start' is > 'wall'
   99 |     if (start > wall)
      |         ^~~~~~~~~~~~
source/algos/kmpskip.c:99:5: note: Taking true branch
   99 |     if (start > wall)
      |     ^
source/algos/kmpskip.c:101:9: note: Calling 'attempt'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:60:3: note: The value 0 is assigned to 'k'
   60 |   k = wall - start;
      |   ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:61:10: note: 'k' is >= 'm'
   61 |   while (k < m && x[k] == y[k + start])
      |          ^
source/algos/kmpskip.c:61:16: note: Left side of '&&' is false
   61 |   while (k < m && x[k] == y[k + start])
      |                ^
source/algos/kmpskip.c:63:3: note: Returning zero (loaded from 'k')
   63 |   return (k);
      |   ^~~~~~~~~~
source/algos/kmpskip.c:101:9: note: Returning from 'attempt'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:101:5: note: The value 0 is assigned to 'k'
  101 |     k = attempt((char*)y, (char*)x, m, start, wall);
      |     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/kmpskip.c:103:9: note: Assuming 'k' is not equal to 'm'
  103 |     if (k == m) {
      |         ^~~~~~
source/algos/kmpskip.c:103:5: note: Taking false branch
  103 |     if (k == m) {
      |     ^
source/algos/kmpskip.c:108:9: note: Assuming 'i' is >= 0
  108 |     if (i < 0) {
      |         ^~~~~
source/algos/kmpskip.c:108:5: note: Taking false branch
  108 |     if (i < 0) {
      |     ^
source/algos/kmpskip.c:119:5: note: The value -1 is assigned to 'k'
  119 |     k = kmpNext[k];
      |     ^~~~~~~~~~~~~~
source/algos/kmpskip.c:121:12: note: Assuming 'start' is >= 'kmpStart'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |            ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:121:12: note: Left side of '||' is false
source/algos/kmpskip.c:121:33: note: Assuming 'kmpStart' is < 'start'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |                                 ^~~~~~~~~~~~~~~~
source/algos/kmpskip.c:121:33: note: Left side of '&&' is true
source/algos/kmpskip.c:121:53: note: Assuming 'start' is < 'wall'
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |                                                     ^~~~~~~~~~~~
source/algos/kmpskip.c:121:5: note: Loop condition is true.  Entering loop body
  121 |     while (start < kmpStart || (kmpStart < start && start < wall)) {
      |     ^
source/algos/kmpskip.c:122:11: note: 'start' is >= 'kmpStart'
  122 |       if (start < kmpStart) {
      |           ^~~~~
source/algos/kmpskip.c:122:7: note: Taking false branch
  122 |       if (start < kmpStart) {
      |       ^
source/algos/kmpskip.c:136:24: note: The right operand of '-' is a garbage value due to array index out of bounds
  136 |         kmpStart += (k - mpNext[k]);
      |                        ^ ~~~~~~~~~
source/algos/ldm.c:67:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   67 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:67:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   67 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:69:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   69 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ldm.c:69:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   69 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/mp.c:56:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   56 |       i = mpNext[i];
      |         ^ ~~~~~~~~~
source/algos/mp.c:42:3: note: Calling 'preMp'
   42 |   preMp(x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/mp.c:30:10: note: Assuming 'i' is >= 'm'
   30 |   while (i < m) {
      |          ^~~~~
source/algos/mp.c:30:3: note: Loop condition is false. Execution continues on line 30
   30 |   while (i < m) {
      |   ^
source/algos/mp.c:42:3: note: Returning from 'preMp'
   42 |   preMp(x, m, mpNext);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/mp.c:43:3: note: Assuming 'pre_time' is null
   43 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/mp.c:43:3: note: Taking false branch
   43 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/mp.c:49:10: note: Assuming 'j' is < 'n'
   49 |   while (j < n) {
      |          ^~~~~
source/algos/mp.c:49:3: note: Loop condition is true.  Entering loop body
   49 |   while (j < n) {
      |   ^
source/algos/mp.c:50:12: note: Left side of '&&' is true
   50 |     while (i > -1 && x[i] != y[j])
      |            ^
source/algos/mp.c:50:22: note: Assuming the condition is false
   50 |     while (i > -1 && x[i] != y[j])
      |                      ^~~~~~~~~~~~
source/algos/mp.c:50:5: note: Loop condition is false. Execution continues on line 52
   50 |     while (i > -1 && x[i] != y[j])
      |     ^
source/algos/mp.c:52:5: note: The value 1 is assigned to 'i'
   52 |     i++;
      |     ^~~
source/algos/mp.c:54:9: note: 'i' is >= 'm'
   54 |     if (i >= m) {
      |         ^
source/algos/mp.c:54:5: note: Taking true branch
   54 |     if (i >= m) {
      |     ^
source/algos/mp.c:56:9: note: Assigned value is garbage or undefined
   56 |       i = mpNext[i];
      |         ^ ~~~~~~~~~
source/algos/rcolussi.c:71:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   71 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/rcolussi.c:71:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   71 |   memset(kmin, 0, m * sizeof(int));
      |   ^~~~~~
source/algos/rf.c:42:31: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   42 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/rf.c:90:7: note: Assuming 'm' is <= M_CUTOFF
   90 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/rf.c:90:3: note: Taking false branch
   90 |   if (m > M_CUTOFF) {
      |   ^
source/algos/rf.c:102:3: note: Calling 'buildSuffixAutomaton'
  102 |   buildSuffixAutomaton(x, m, ttrans, tlength, tsuffix, tterminal);
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/rf.c:33:3: note: The value 0 is assigned to 'init'
   33 |   init = 0;
      |   ^~~~~~~~
source/algos/rf.c:37:3: note: The value 0 is assigned to 'last'
   37 |   last = init;
      |   ^~~~~~~~~~~
source/algos/rf.c:38:19: note: Assuming 'i' is >= 0
   38 |   for (i = m - 1; i >= 0; --i) {
      |                   ^~~~~~
source/algos/rf.c:38:3: note: Loop condition is true.  Entering loop body
   38 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/rf.c:40:5: note: The value 0 is assigned to 'p'
   40 |     p = last;
      |     ^~~~~~~~
source/algos/rf.c:42:31: note: The left operand of '+' is a garbage value
   42 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/include/AUTOMATON.h:23:41: note: expanded from macro 'setLength'
   23 | #define setLength(p, q) tlength[(p)] = (q)
      |                                         ^
source/algos/rf.c:55:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   55 |       memcpy(ttrans + r * SIGMA, ttrans + getTarget(p, c) * SIGMA,
      |       ^~~~~~
source/algos/rf.c:55:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   55 |       memcpy(ttrans + r * SIGMA, ttrans + getTarget(p, c) * SIGMA,
      |       ^~~~~~
source/algos/rf.c:101:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  101 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/rf.c:101:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  101 |   memset(ttrans, -1, (2 * m + 3) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/sbndm-bmh.c:55:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
   55 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:55:3: note: Value stored to 's' is never read
   55 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:130:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
  130 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm-bmh.c:130:3: note: Value stored to 's' is never read
  130 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:51:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
   51 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:51:3: note: Value stored to 's' is never read
   51 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:122:3: warning: Value stored to 's' is never read [clang-analyzer-deadcode.DeadStores]
  122 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sbndm.c:122:3: note: Value stored to 's' is never read
  122 |   s = (unsigned int)(~0) << (WORD - m);
      |   ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/sebom.c:58:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   58 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sebom.c:34:7: note: Assuming 'm' is >= 2
   34 |   if (m < 2)
      |       ^~~~~
source/algos/sebom.c:34:3: note: Taking false branch
   34 |   if (m < 2)
      |   ^
source/algos/sebom.c:41:7: note: Assuming the condition is false
   41 |   if (m + 2 > M_CUTOFF) {
      |       ^~~~~~~~~~~~~~~~
source/algos/sebom.c:41:3: note: Taking false branch
   41 |   if (m + 2 > M_CUTOFF) {
      |   ^
source/algos/sebom.c:46:17: note: Assuming the condition is false
   46 |     for (i = 0; i <= m + 1; i++)
      |                 ^~~~~~~~~~
source/algos/sebom.c:46:5: note: Loop condition is false. Execution continues on line 51
   46 |     for (i = 0; i <= m + 1; i++)
      |     ^
source/algos/sebom.c:51:3: note: Loop condition is false. Execution continues on line 54
   51 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sebom.c:55:8: note: The value 2147483647 is assigned to 'i'
   55 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/sebom.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/sebom.c:58:17: note: Array access results in an undefined pointer dereference
   58 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sfbom.c:54:17: warning: Array access results in an undefined pointer dereference [clang-analyzer-core.NullDereference]
   54 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/sfbom.c:38:7: note: Assuming the condition is false
   38 |   if (m + 2 > M_CUTOFF) {
      |       ^~~~~~~~~~~~~~~~
source/algos/sfbom.c:38:3: note: Taking false branch
   38 |   if (m + 2 > M_CUTOFF) {
      |   ^
source/algos/sfbom.c:43:17: note: Assuming the condition is false
   43 |     for (i = 0; i <= m + 1; i++)
      |                 ^~~~~~~~~~
source/algos/sfbom.c:43:5: note: Loop condition is false. Execution continues on line 47
   43 |     for (i = 0; i <= m + 1; i++)
      |     ^
source/algos/sfbom.c:47:3: note: Loop condition is false. Execution continues on line 50
   47 |   for (i = 0; i <= m + 1; i++)
      |   ^
source/algos/sfbom.c:51:8: note: Value assigned to 'i'
   51 |   for (i = m; i > 0; --i) {
      |        ^~~~~
source/algos/sfbom.c:51:15: note: Assuming 'i' is > 0
   51 |   for (i = m; i > 0; --i) {
      |               ^~~~~
source/algos/sfbom.c:51:3: note: Loop condition is true.  Entering loop body
   51 |   for (i = m; i > 0; --i) {
      |   ^
source/algos/sfbom.c:54:17: note: Array access results in an undefined pointer dereference
   54 |     trans[i][c] = iMinus1;
      |     ~~~~~~~~~~~~^~~~~~~~~
source/algos/simon.c:55:8: warning: Address of stack memory associated with local variable 's_cells' is still referred to by the stack variable 'L' upon returning to the caller.  This will be a dangling reference [clang-analyzer-core.StackAddressEscape]
   55 |   L[p] = cell;
      |        ^
source/algos/simon.c:90:9: note: Calling 'preSimon'
   90 |   ell = preSimon(x, m, L);
      |         ^~~~~~~~~~~~~~~~~
source/algos/simon.c:64:15: note: Assuming 'i' is < 'm'
   64 |   for (i = 1; i < m; ++i) {
      |               ^~~~~
source/algos/simon.c:64:3: note: Loop condition is true.  Entering loop body
   64 |   for (i = 1; i < m; ++i) {
      |   ^
source/algos/simon.c:66:13: note: '?' condition is true
   66 |     cell = (ell == -1 ? NULL : L[k]);
      |             ^
source/algos/simon.c:68:9: note: Assuming the condition is false
   68 |     if (x[i] == x[k + 1])
      |         ^~~~~~~~~~~~~~~~
source/algos/simon.c:68:5: note: Taking false branch
   68 |     if (x[i] == x[k + 1])
      |     ^
source/algos/simon.c:71:7: note: Calling 'setTransitionSimon'
   71 |       setTransitionSimon(i - 1, k + 1, L, m, j++);
      |       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/algos/simon.c:46:7: note: Assuming 'm' is <= M_CUTOFF
   46 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/simon.c:46:3: note: Taking false branch
   46 |   if (m > M_CUTOFF) {
      |   ^
source/algos/simon.c:55:8: note: Address of stack memory associated with local variable 's_cells' is still referred to by the stack variable 'L' upon returning to the caller.  This will be a dangling reference
   44 |   struct _cell s_cells[2 * M_CUTOFF];
      |   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   45 | 
   46 |   if (m > M_CUTOFF) {
   47 |     cell = (List)malloc(sizeof(struct _cell));
   48 |     if (cell == NULL)
   49 |       error("SIMON/setTransition");
   50 |   } else {
   51 |     cell = &s_cells[j];
   52 |   }
   53 |   cell->element = q;
   54 |   cell->next = L[p];
   55 |   L[p] = cell;
      |        ^
source/algos/simon.c:62:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   62 |   memset(L, 0, m * sizeof(List));
      |   ^~~~~~
source/algos/simon.c:62:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   62 |   memset(L, 0, m * sizeof(List));
      |   ^~~~~~
source/algos/skip.c:42:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   42 |   memset(z, 0, SIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip.c:42:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   42 |   memset(z, 0, SIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip2.c:54:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   54 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip2.c:54:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   54 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip3.c:50:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   50 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip3.c:50:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   50 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip4.c:50:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   50 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip4.c:50:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   50 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip5.c:51:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   51 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip5.c:51:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   51 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip6.c:52:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip6.c:52:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip7.c:52:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip7.c:52:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip8.c:52:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/skip8.c:52:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   52 |   memset(z, 0, DSIGMA * sizeof(List));
      |   ^~~~~~
source/algos/ssef.c:52:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   52 |   memset(flist, 0, sizeof(LIST *) * 65536);
      |   ^~~~~~
source/algos/ssef.c:52:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   52 |   memset(flist, 0, sizeof(LIST *) * 65536);
      |   ^~~~~~
source/algos/ssef.c:75:3: warning: Value stored to 'count' is never read [clang-analyzer-deadcode.DeadStores]
   75 |   count = 15;
      |   ^       ~~
source/algos/ssef.c:75:3: note: Value stored to 'count' is never read
   75 |   count = 15;
      |   ^       ~~
source/algos/ssm.c:88:3: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   88 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/ssm.c:88:3: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   88 |   memcpy(y + n, x, m);
      |   ^~~~~~
source/algos/tbm.c:63:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   63 |         if (bmGs[j] == m)
      |                     ^
source/algos/tbm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/tbm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/tbm.c:59:3: note: The value 0 is assigned to 'j'
   59 |   j = 0;
      |   ^~~~~
source/algos/tbm.c:60:19: note: Assuming 'i' is >= 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/tbm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:61:9: note: Assuming the condition is false
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/tbm.c:61:5: note: Taking false branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/tbm.c:60:3: note: Loop condition is true.  Entering loop body
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:61:9: note: Assuming the condition is true
   61 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/tbm.c:61:5: note: Taking true branch
   61 |     if (suff[i] == i + 1)
      |     ^
source/algos/tbm.c:62:7: note: Loop condition is true.  Entering loop body
   62 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/tbm.c:63:21: note: The left operand of '==' is a garbage value
   63 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/tbm.c:92:13: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   92 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/tbm.c:74:3: note: Calling 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:57:15: note: Assuming 'i' is >= 'm'
   57 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/tbm.c:57:3: note: Loop condition is false. Execution continues on line 59
   57 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/tbm.c:60:19: note: Assuming 'i' is < 0
   60 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/tbm.c:60:3: note: Loop condition is false. Execution continues on line 65
   60 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/tbm.c:65:15: note: Assuming the condition is false
   65 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/tbm.c:65:3: note: Loop condition is false. Execution continues on line 65
   65 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/tbm.c:67:1: note: Returning without writing to '*bmGs'
   67 | }
      | ^
source/algos/tbm.c:74:3: note: Returning from 'preBmGs'
   74 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/tbm.c:76:3: note: Assuming 'pre_time' is null
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/tbm.c:76:3: note: Taking false branch
   76 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/tbm.c:83:10: note: Assuming the condition is true
   83 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/tbm.c:83:3: note: Loop condition is true.  Entering loop body
   83 |   while (j <= n - m) {
      |   ^
source/algos/tbm.c:85:12: note: 'i' is < 0
   85 |     while (i >= 0 && x[i] == y[i + j]) {
      |            ^
source/algos/tbm.c:85:19: note: Left side of '&&' is false
   85 |     while (i >= 0 && x[i] == y[i + j]) {
      |                   ^
source/algos/tbm.c:90:9: note: 'i' is < 0
   90 |     if (i < 0) {
      |         ^
source/algos/tbm.c:90:5: note: Taking true branch
   90 |     if (i < 0) {
      |     ^
source/algos/tbm.c:92:13: note: Assigned value is garbage or undefined
   92 |       shift = bmGs[0];
      |             ^ ~~~~~~~
source/algos/trf.c:55:31: warning: The left operand of '+' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   55 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/trf.c:111:7: note: Assuming 'm' is <= M_CUTOFF
  111 |   if (m > M_CUTOFF) {
      |       ^~~~~~~~~~~~
source/algos/trf.c:111:3: note: Taking false branch
  111 |   if (m > M_CUTOFF) {
      |   ^
source/algos/trf.c:129:3: note: Calling 'buildSuffixAutomaton4TRF'
  129 |   buildSuffixAutomaton4TRF(x, m, ttrans, tlength, tposition, tsuffix, tterminal,
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  130 |                            tshift);
      |                            ~~~~~~~
source/algos/trf.c:45:3: note: 'init' initialized to 0
   45 |   const int init = 0;
      |   ^~~~~~~~~~~~~~
source/algos/trf.c:50:3: note: The value 0 is assigned to 'last'
   50 |   last = init;
      |   ^~~~~~~~~~~
source/algos/trf.c:51:19: note: Assuming 'i' is >= 0
   51 |   for (i = m - 1; i >= 0; --i) {
      |                   ^~~~~~
source/algos/trf.c:51:3: note: Loop condition is true.  Entering loop body
   51 |   for (i = m - 1; i >= 0; --i) {
      |   ^
source/algos/trf.c:53:5: note: The value 0 is assigned to 'p'
   53 |     p = last;
      |     ^~~~~~~~
source/algos/trf.c:55:31: note: The left operand of '+' is a garbage value
   55 |     setLength(q, getLength(p) + 1);
      |                               ^
source/algos/include/AUTOMATON.h:23:41: note: expanded from macro 'setLength'
   23 | #define setLength(p, q) tlength[(p)] = (q)
      |                                         ^
source/algos/trf.c:71:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   71 |       memcpy(ttrans + r * SIGMA, ttrans + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:71:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   71 |       memcpy(ttrans + r * SIGMA, ttrans + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:72:7: warning: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   72 |       memcpy(tshift + r * SIGMA, tshift + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:72:7: note: Call to function 'memcpy' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memcpy_s' in case of C11
   72 |       memcpy(tshift + r * SIGMA, tshift + tmp * SIGMA, SIGMA * sizeof(int));
      |       ^~~~~~
source/algos/trf.c:128:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  128 |   memset(ttrans, -1, size * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/trf.c:128:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
  128 |   memset(ttrans, -1, size * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/trf.c:134:3: warning: Value stored to 'i' is never read [clang-analyzer-deadcode.DeadStores]
  134 |   i = 0;
      |   ^   ~
source/algos/trf.c:134:3: note: Value stored to 'i' is never read
  134 |   i = 0;
      |   ^   ~
source/algos/tsa-q2.c:31:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   31 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa-q2.c:31:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   31 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa.c:21:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   21 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tsa.c:21:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   21 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tso5.c:25:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   25 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tso5.c:25:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   25 |   memset(B, 0, 256 * 4);
      |   ^~~~~~
source/algos/tunbm.c:47:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   47 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunbm.c:47:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   47 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunedbm.c:43:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   43 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/tunedbm.c:43:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   43 |   memset(y + n, x[m - 1], m);
      |   ^~~~~~
source/algos/ww.c:33:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   33 |   memset(ttransSMA, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:33:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   33 |   memset(ttransSMA, 0, SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:71:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   71 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:71:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   71 |   memset(ttrans, -1, 3 * m * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:74:3: warning: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
   74 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/ww.c:74:3: note: Call to function 'memset' is insecure as it does not provide security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'memset_s' in case of C11
   74 |   memset(ttransSMA, -1, (m + 1) * SIGMA * sizeof(int));
      |   ^~~~~~
source/algos/zt.c:58:21: warning: The left operand of '==' is a garbage value [clang-analyzer-core.UndefinedBinaryOperatorResult]
   58 |         if (bmGs[j] == m)
      |                     ^
source/algos/zt.c:82:3: note: Calling 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:52:15: note: Assuming 'i' is >= 'm'
   52 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/zt.c:52:3: note: Loop condition is false. Execution continues on line 54
   52 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/zt.c:54:3: note: The value 0 is assigned to 'j'
   54 |   j = 0;
      |   ^~~~~
source/algos/zt.c:55:19: note: Assuming 'i' is >= 0
   55 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/zt.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:56:9: note: Assuming the condition is false
   56 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/zt.c:56:5: note: Taking false branch
   56 |     if (suff[i] == i + 1)
      |     ^
source/algos/zt.c:55:3: note: Loop condition is true.  Entering loop body
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:56:9: note: Assuming the condition is true
   56 |     if (suff[i] == i + 1)
      |         ^~~~~~~~~~~~~~~~
source/algos/zt.c:56:5: note: Taking true branch
   56 |     if (suff[i] == i + 1)
      |     ^
source/algos/zt.c:57:7: note: Loop condition is true.  Entering loop body
   57 |       for (; j < m - 1 - i; ++j)
      |       ^
source/algos/zt.c:58:21: note: The left operand of '==' is a garbage value
   58 |         if (bmGs[j] == m)
      |             ~~~~~~~ ^
source/algos/zt.c:97:9: warning: Assigned value is garbage or undefined [clang-analyzer-core.uninitialized.Assign]
   97 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/algos/zt.c:82:3: note: Calling 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:52:15: note: Assuming 'i' is >= 'm'
   52 |   for (i = 0; i < m; ++i)
      |               ^~~~~
source/algos/zt.c:52:3: note: Loop condition is false. Execution continues on line 54
   52 |   for (i = 0; i < m; ++i)
      |   ^
source/algos/zt.c:55:19: note: Assuming 'i' is < 0
   55 |   for (i = m - 1; i >= 0; --i)
      |                   ^~~~~~
source/algos/zt.c:55:3: note: Loop condition is false. Execution continues on line 60
   55 |   for (i = m - 1; i >= 0; --i)
      |   ^
source/algos/zt.c:60:15: note: Assuming the condition is false
   60 |   for (i = 0; i <= m - 2; ++i)
      |               ^~~~~~~~~~
source/algos/zt.c:60:3: note: Loop condition is false. Execution continues on line 60
   60 |   for (i = 0; i <= m - 2; ++i)
      |   ^
source/algos/zt.c:62:1: note: Returning without writing to '*bmGs'
   62 | }
      | ^
source/algos/zt.c:82:3: note: Returning from 'preBmGs'
   82 |   preBmGs(x, m, bmGs);
      |   ^~~~~~~~~~~~~~~~~~~
source/algos/zt.c:83:15: note: 'i' is >= 'm'
   83 |   for (i = 0; i < m; i++)
      |               ^
source/algos/zt.c:83:3: note: Loop condition is false. Execution continues on line 85
   83 |   for (i = 0; i < m; i++)
      |   ^
source/algos/zt.c:85:3: note: Assuming 'pre_time' is null
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:9: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |         ^~~~~~~~
source/algos/zt.c:85:3: note: Taking false branch
   85 |   END_PREPROCESSING
      |   ^
source/algos/include/main.h:51:5: note: expanded from macro 'END_PREPROCESSING'
   51 |     if (pre_time)                                                              \
      |     ^
source/algos/zt.c:91:10: note: Assuming the condition is true
   91 |   while (j <= n - m) {
      |          ^~~~~~~~~~
source/algos/zt.c:91:3: note: Loop condition is true.  Entering loop body
   91 |   while (j <= n - m) {
      |   ^
source/algos/zt.c:93:12: note: 'i' is < 0
   93 |     while (i >= 0 && x[i] == y[i + j])
      |            ^
source/algos/zt.c:93:19: note: Left side of '&&' is false
   93 |     while (i >= 0 && x[i] == y[i + j])
      |                   ^
source/algos/zt.c:95:9: note: 'i' is < 0
   95 |     if (i < 0) {
      |         ^
source/algos/zt.c:95:5: note: Taking true branch
   95 |     if (i < 0) {
      |     ^
source/algos/zt.c:97:9: note: Assigned value is garbage or undefined
   97 |       j += bmGs[0];
      |         ^  ~~~~~~~
source/compilesm.c:38:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   38 |   strcat(options, " -Wall");
      |   ^~~~~~
source/compilesm.c:38:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   38 |   strcat(options, " -Wall");
      |   ^~~~~~
source/compilesm.c:41:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   41 |   strcat(options, " -march=native -mtune=native");
      |   ^~~~~~
source/compilesm.c:41:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   41 |   strcat(options, " -march=native -mtune=native");
      |   ^~~~~~
source/compilesm.c:60:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   60 |   strcat(options, " -lm");
      |   ^~~~~~
source/compilesm.c:60:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   60 |   strcat(options, " -lm");
      |   ^~~~~~
source/compilesm.c:70:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   70 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:70:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   70 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:77:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
   77 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:67:3: note: Value assigned to 'd'
   67 |   d = opendir(destdir);
      |   ^~~~~~~~~~~~~~~~~~~~
source/compilesm.c:68:7: note: Assuming 'd' is null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking false branch
   68 |   if (d) {
      |   ^
source/compilesm.c:77:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
   77 |   closedir(d);
      |   ^        ~
source/compilesm.c:84:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   84 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:84:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   84 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:91:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
   91 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:80:3: note: Value assigned to 'd'
   80 |   d = opendir("./source/algos");
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:82:7: note: Assuming 'd' is null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking false branch
   82 |   if (d) {
      |   ^
source/compilesm.c:91:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
   91 |   closedir(d);
      |   ^        ~
source/compilesm.c:99:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   99 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:99:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
   99 |       strcpy(filename, dir->d_name);
      |       ^~~~~~
source/compilesm.c:126:54: warning: Division by zero [clang-analyzer-core.DivideZero]
  126 |         printf("\b\b\b\b\b\b[%.3d%%]", current * 100 / n_algo);
      |                                        ~~~~~~~~~~~~~~^~~~~~~~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:81:3: note: 'n_algo' initialized to 0
   81 |   int n_algo = 0;
      |   ^~~~~~~~~~
source/compilesm.c:82:7: note: Assuming 'd' is non-null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking true branch
   82 |   if (d) {
      |   ^
source/compilesm.c:83:12: note: Assuming the condition is false
   83 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:83:5: note: Loop condition is false. Execution continues on line 91
   83 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:97:7: note: Assuming 'd' is non-null
   97 |   if (d) {
      |       ^
source/compilesm.c:97:3: note: Taking true branch
   97 |   if (d) {
      |   ^
source/compilesm.c:98:12: note: Assuming the condition is true
   98 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:98:5: note: Loop condition is true.  Entering loop body
   98 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:101:11: note: Assuming 'len' is > 2
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |           ^~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
source/compilesm.c:101:22: note: Assuming the condition is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |                      ^~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |           ^
source/compilesm.c:101:50: note: Assuming the condition is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |                                                  ^~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |           ^
source/compilesm.c:102:14: note: Assuming the condition is true
  102 |           && filename[0] != '.' && filename[1] != '#') {
      |              ^~~~~~~~~~~~~~~~~~
source/compilesm.c:101:11: note: Left side of '&&' is true
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |           ^
source/compilesm.c:102:36: note: Assuming the condition is true
  102 |           && filename[0] != '.' && filename[1] != '#') {
      |                                    ^~~~~~~~~~~~~~~~~~
source/compilesm.c:101:7: note: Taking true branch
  101 |       if (len > 2 && filename[len - 1] == 'c' && filename[len - 2] == '.'
      |       ^
source/compilesm.c:117:13: note: 'doTest' is 0
  117 |         if (doTest)
      |             ^~~~~~
source/compilesm.c:117:9: note: Taking false branch
  117 |         if (doTest)
      |         ^
source/compilesm.c:121:21: note: Assuming the condition is false
  121 |         for (i = 0; i < 15 - (int)strlen(filename); i++)
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:121:9: note: Loop condition is false. Execution continues on line 123
  121 |         for (i = 0; i < 15 - (int)strlen(filename); i++)
      |         ^
source/compilesm.c:126:54: note: Division by zero
  126 |         printf("\b\b\b\b\b\b[%.3d%%]", current * 100 / n_algo);
      |                                        ~~~~~~~~~~~~~~^~~~~~~~
source/compilesm.c:139:37: warning: Potential buffer overflow. Replace with 'sizeof(binary) - strlen(binary) - 1' or use a safer 'strlcat' API [clang-analyzer-unix.cstring.BadSizeArg]
  139 |           strncat(binary, filename, sizeof(binary) - 1);
      |                                     ^~~~~~~~~~~~~~~~~~
source/compilesm.c:139:37: note: Potential buffer overflow. Replace with 'sizeof(binary) - strlen(binary) - 1' or use a safer 'strlcat' API
  139 |           strncat(binary, filename, sizeof(binary) - 1);
      |                                     ^~~~~~~~~~~~~~~~~~
source/compilesm.c:172:3: warning: Null pointer passed to 1st parameter expecting 'nonnull' [clang-analyzer-core.NonNullParamChecker]
  172 |   closedir(d);
      |   ^        ~
source/compilesm.c:55:7: note: Assuming 'argc' is <= 1
   55 |   if (argc > 1) {
      |       ^~~~~~~~
source/compilesm.c:55:3: note: Taking false branch
   55 |   if (argc > 1) {
      |   ^
source/compilesm.c:68:7: note: Assuming 'd' is non-null
   68 |   if (d) {
      |       ^
source/compilesm.c:68:3: note: Taking true branch
   68 |   if (d) {
      |   ^
source/compilesm.c:69:12: note: Assuming the condition is false
   69 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:69:5: note: Loop condition is false. Execution continues on line 77
   69 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:82:7: note: Assuming 'd' is non-null
   82 |   if (d) {
      |       ^
source/compilesm.c:82:3: note: Taking true branch
   82 |   if (d) {
      |   ^
source/compilesm.c:83:12: note: Assuming the condition is false
   83 |     while ((dir = readdir(d)) != NULL) {
      |            ^~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:83:5: note: Loop condition is false. Execution continues on line 91
   83 |     while ((dir = readdir(d)) != NULL) {
      |     ^
source/compilesm.c:96:3: note: Value assigned to 'd'
   96 |   d = opendir("./source/algos");
      |   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/compilesm.c:97:7: note: Assuming 'd' is null
   97 |   if (d) {
      |       ^
source/compilesm.c:97:3: note: Taking false branch
   97 |   if (d) {
      |   ^
source/compilesm.c:172:3: note: Null pointer passed to 1st parameter expecting 'nonnull'
  172 |   closedir(d);
      |   ^        ~
source/selectAlgo.c:90:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   90 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:90:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   90 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:91:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
   91 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:91:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
   91 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:121:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  121 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:121:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  121 |           strcat(buf, ALGO_NAME[i]);
      |           ^~~~~~
source/selectAlgo.c:122:11: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  122 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:122:11: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  122 |           strcat(buf, ".c");
      |           ^~~~~~
source/selectAlgo.c:149:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  149 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:149:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  149 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:151:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  151 |       strcat(path, algo);
      |       ^~~~~~
source/selectAlgo.c:151:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  151 |       strcat(path, algo);
      |       ^~~~~~
source/selectAlgo.c:165:11: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  165 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:165:11: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  165 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:196:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  196 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:196:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  196 |       strcpy(filename, algo);
      |       ^~~~~~
source/selectAlgo.c:198:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  198 |       strcat(path, filename);
      |       ^~~~~~
source/selectAlgo.c:198:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  198 |       strcat(path, filename);
      |       ^~~~~~
source/selectAlgo.c:212:11: warning: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11 [clang-analyzer-security.insecureAPI.DeprecatedOrUnsafeBufferHandling]
  212 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/selectAlgo.c:212:11: note: Call to function 'sprintf' is insecure as it does not provide bounding of the memory buffer or security checks introduced in the C11 standard. Replace with analogous functions that support length arguments or provides boundary checks such as 'sprintf_s' in case of C11
  212 |           sprintf(command, "./test %s -nv", algo);
      |           ^~~~~~~
source/smart.c:122:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  122 |   strcpy(indexfilename, path);
      |   ^~~~~~
source/smart.c:122:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  122 |   strcpy(indexfilename, path);
      |   ^~~~~~
source/smart.c:123:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  123 |   strcat(indexfilename, "/index.txt");
      |   ^~~~~~
source/smart.c:123:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  123 |   strcat(indexfilename, "/index.txt");
      |   ^~~~~~
source/smart.c:130:9: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  130 |         strcpy(filename, path);
      |         ^~~~~~
source/smart.c:130:9: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  130 |         strcpy(filename, path);
      |         ^~~~~~
source/smart.c:193:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  193 |       strcpy((char *)setP[i], (char *)simplePattern);
      |       ^~~~~~
source/smart.c:193:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  193 |       strcpy((char *)setP[i], (char *)simplePattern);
      |       ^~~~~~
source/smart.c:249:5: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  249 |     strcat(logfile, "/errorlog.txt");
      |     ^~~~~~
source/smart.c:249:5: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  249 |     strcat(logfile, "/errorlog.txt");
      |     ^~~~~~
source/smart.c:441:17: warning: variable 'nchar' set but not used [clang-diagnostic-unused-but-set-variable]
  441 |             int nchar = 15;
      |                 ^
source/smart.c:445:15: warning: Value stored to 'nchar' is never read [clang-analyzer-deadcode.DeadStores]
  445 |               nchar += 15;
      |               ^        ~~
source/smart.c:445:15: note: Value stored to 'nchar' is never read
  445 |               nchar += 15;
      |               ^        ~~
source/smart.c:513:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  513 |   strcpy(filename, "");
      |   ^~~~~~
source/smart.c:513:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  513 |   strcpy(filename, "");
      |   ^~~~~~
source/smart.c:561:9: warning: Potential leak of memory pointed to by 'filename' [clang-analyzer-unix.Malloc]
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:512:28: note: Memory is allocated
  512 |   char *filename = (char *)malloc(sizeof(char) * (100));
      |                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:542:7: note: Assuming 'argc' is not equal to 1
  542 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:542:3: note: Taking false branch
  542 |   if (argc == 1) {
      |   ^
source/smart.c:549:7: note: Assuming the condition is false
  549 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:549:3: note: Taking false branch
  549 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:557:10: note: 'par' is < 'argc'
  557 |   while (par < argc) {
      |          ^~~
source/smart.c:557:3: note: Loop condition is true.  Entering loop body
  557 |   while (par < argc) {
      |   ^
source/smart.c:558:9: note: 'par' is < 'argc'
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:558:9: note: Left side of '&&' is true
source/smart.c:558:5: note: Taking true branch
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:560:11: note: Assuming 'par' is >= 'argc'
  560 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:560:7: note: Taking true branch
  560 |       if (par >= argc) {
      |       ^
source/smart.c:561:9: note: Potential leak of memory pointed to by 'filename'
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:561:9: warning: Potential leak of memory pointed to by 'simplePattern' [clang-analyzer-unix.Malloc]
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:529:51: note: Memory is allocated
  529 |   unsigned char *simplePattern = (unsigned char *)malloc(
      |                                                   ^~~~~~~
  530 |       sizeof(unsigned char) * (100)); // used for the simple run of SMART
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:542:7: note: Assuming 'argc' is not equal to 1
  542 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:542:3: note: Taking false branch
  542 |   if (argc == 1) {
      |   ^
source/smart.c:549:7: note: Assuming the condition is false
  549 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:549:3: note: Taking false branch
  549 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:557:10: note: 'par' is < 'argc'
  557 |   while (par < argc) {
      |          ^~~
source/smart.c:557:3: note: Loop condition is true.  Entering loop body
  557 |   while (par < argc) {
      |   ^
source/smart.c:558:9: note: 'par' is < 'argc'
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:558:9: note: Left side of '&&' is true
source/smart.c:558:5: note: Taking true branch
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:560:11: note: Assuming 'par' is >= 'argc'
  560 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:560:7: note: Taking true branch
  560 |       if (par >= argc) {
      |       ^
source/smart.c:561:9: note: Potential leak of memory pointed to by 'simplePattern'
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:561:9: warning: Potential leak of memory pointed to by 'simpleText' [clang-analyzer-unix.Malloc]
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:531:48: note: Memory is allocated
  531 |   unsigned char *simpleText = (unsigned char *)malloc(
      |                                                ^~~~~~~
  532 |       sizeof(unsigned char) * (1000)); // used for the simple run of SMART
      |       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source/smart.c:542:7: note: Assuming 'argc' is not equal to 1
  542 |   if (argc == 1) {
      |       ^~~~~~~~~
source/smart.c:542:3: note: Taking false branch
  542 |   if (argc == 1) {
      |   ^
source/smart.c:549:7: note: Assuming the condition is false
  549 |   if (!strcmp("-h", argv[1])) {
      |       ^~~~~~~~~~~~~~~~~~~~~~
source/smart.c:549:3: note: Taking false branch
  549 |   if (!strcmp("-h", argv[1])) {
      |   ^
source/smart.c:557:10: note: 'par' is < 'argc'
  557 |   while (par < argc) {
      |          ^~~
source/smart.c:557:3: note: Loop condition is true.  Entering loop body
  557 |   while (par < argc) {
      |   ^
source/smart.c:558:9: note: 'par' is < 'argc'
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |         ^~~
source/smart.c:558:9: note: Left side of '&&' is true
source/smart.c:558:5: note: Taking true branch
  558 |     if (par < argc && !strcmp("-pset", argv[par])) {
      |     ^
source/smart.c:560:11: note: Assuming 'par' is >= 'argc'
  560 |       if (par >= argc) {
      |           ^~~~~~~~~~~
source/smart.c:560:7: note: Taking true branch
  560 |       if (par >= argc) {
      |       ^
source/smart.c:561:9: note: Potential leak of memory pointed to by 'simpleText'
  561 |         printf("Error in input parameters. Use -h for help.\n\n");
      |         ^
source/smart.c:564:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  564 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:564:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  564 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:577:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  577 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:577:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  577 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:591:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  591 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:591:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  591 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:604:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  604 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:604:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  604 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:605:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  605 |       strcat(filename, parameter);
      |       ^~~~~~
source/smart.c:605:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  605 |       strcat(filename, parameter);
      |       ^~~~~~
source/smart.c:613:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  613 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:613:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  613 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:625:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  625 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:625:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  625 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:640:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  640 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:640:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  640 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:641:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  641 |       strcpy((char *)simplePattern, parameter);
      |       ^~~~~~
source/smart.c:641:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  641 |       strcpy((char *)simplePattern, parameter);
      |       ^~~~~~
source/smart.c:650:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  650 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:650:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  650 |       strcpy(parameter, argv[par++]);
      |       ^~~~~~
source/smart.c:651:7: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  651 |       strcpy((char *)simpleText, parameter);
      |       ^~~~~~
source/smart.c:651:7: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  651 |       strcpy((char *)simpleText, parameter);
      |       ^~~~~~
source/smart.c:750:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  750 |     strcpy((char *)T, (char *)simpleText);
      |     ^~~~~~
source/smart.c:750:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  750 |     strcpy((char *)T, (char *)simpleText);
      |     ^~~~~~
source/smart.c:791:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  791 |       strcat(fullpath, list_of_filenames[k]);
      |       ^~~~~~
source/smart.c:791:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  791 |       strcat(fullpath, list_of_filenames[k]);
      |       ^~~~~~
source/smart.c:829:7: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  829 |       strcat(fullpath, SETTING_BUFFER[sett]);
      |       ^~~~~~
source/smart.c:829:7: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  829 |       strcat(fullpath, SETTING_BUFFER[sett]);
      |       ^~~~~~
source/test.c:175:5: warning: Potential leak of memory pointed to by 'pP' [clang-analyzer-unix.Malloc]
  175 |   (*rip)++;
      |     ^
source/test.c:132:7: note: Assuming the condition is true
  132 |   if (VERBOSE) {
      |       ^
source/test.c:49:17: note: expanded from macro 'VERBOSE'
   49 | #define VERBOSE strcmp(parameter, "-nv")
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~
source/test.c:132:3: note: Taking true branch
  132 |   if (VERBOSE) {
      |   ^
source/test.c:133:10: note: Calling 'printable'
  133 |     pP = printable((char*)P);
      |          ^~~~~~~~~~~~~~~~~~~
source/function.h:48:15: note: Memory is allocated
   48 |   char* ret = calloc(sz, 1);
      |               ^~~~~~~~~~~~~
source/function.h:49:10: note: 'n' is >= 0
   49 |   while (n >= 0) {
      |          ^
source/function.h:49:3: note: Loop condition is true.  Entering loop body
   49 |   while (n >= 0) {
      |   ^
source/function.h:50:9: note: Assuming the condition is true
   50 |     if (!isgraph(s[n]) || s[n] == '\'' || s[n] == ' '|| s[n] == '"') {
      |         ^~~~~~~~~~~~~~
source/function.h:50:24: note: Left side of '||' is true
   50 |     if (!isgraph(s[n]) || s[n] == '\'' || s[n] == ' '|| s[n] == '"') {
      |                        ^
source/function.h:53:11: note: Assuming the condition is false
   53 |       if (strlen(ret) + n + 5 > sz) {
      |           ^~~~~~~~~~~~~~~~~~~~~~~~
source/function.h:53:7: note: Taking false branch
   53 |       if (strlen(ret) + n + 5 > sz) {
      |       ^
source/function.h:49:10: note: Assuming 'n' is < 0
   49 |   while (n >= 0) {
      |          ^~~~~~
source/function.h:49:3: note: Loop condition is false. Execution continues on line 66
   49 |   while (n >= 0) {
      |   ^
source/test.c:133:10: note: Returned allocated memory
  133 |     pP = printable((char*)P);
      |          ^~~~~~~~~~~~~~~~~~~
source/test.c:148:7: note: 'occur2' is < 0
  148 |   if (occur2 >= 0 && occur1 != occur2) {
      |       ^~~~~~
source/test.c:148:19: note: Left side of '&&' is false
  148 |   if (occur2 >= 0 && occur1 != occur2) {
      |                   ^
source/test.c:167:9: note: Assuming the condition is false
  167 |     if (VERBOSE) {
      |         ^
source/test.c:49:17: note: expanded from macro 'VERBOSE'
   49 | #define VERBOSE strcmp(parameter, "-nv")
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~
source/test.c:167:5: note: Taking false branch
  167 |     if (VERBOSE) {
      |     ^
source/test.c:175:5: note: Potential leak of memory pointed to by 'pP'
  175 |   (*rip)++;
      |     ^
source/test.c:175:5: warning: Potential leak of memory pointed to by 'pT' [clang-analyzer-unix.Malloc]
  175 |   (*rip)++;
      |     ^
source/test.c:132:7: note: Assuming the condition is true
  132 |   if (VERBOSE) {
      |       ^
source/test.c:49:17: note: expanded from macro 'VERBOSE'
   49 | #define VERBOSE strcmp(parameter, "-nv")
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~
source/test.c:132:3: note: Taking true branch
  132 |   if (VERBOSE) {
      |   ^
source/test.c:134:10: note: Calling 'printable'
  134 |     pT = printable((char*)T);
      |          ^~~~~~~~~~~~~~~~~~~
source/function.h:48:15: note: Memory is allocated
   48 |   char* ret = calloc(sz, 1);
      |               ^~~~~~~~~~~~~
source/function.h:49:10: note: 'n' is >= 0
   49 |   while (n >= 0) {
      |          ^
source/function.h:49:3: note: Loop condition is true.  Entering loop body
   49 |   while (n >= 0) {
      |   ^
source/function.h:50:9: note: Assuming the condition is true
   50 |     if (!isgraph(s[n]) || s[n] == '\'' || s[n] == ' '|| s[n] == '"') {
      |         ^~~~~~~~~~~~~~
source/function.h:50:24: note: Left side of '||' is true
   50 |     if (!isgraph(s[n]) || s[n] == '\'' || s[n] == ' '|| s[n] == '"') {
      |                        ^
source/function.h:53:11: note: Assuming the condition is false
   53 |       if (strlen(ret) + n + 5 > sz) {
      |           ^~~~~~~~~~~~~~~~~~~~~~~~
source/function.h:53:7: note: Taking false branch
   53 |       if (strlen(ret) + n + 5 > sz) {
      |       ^
source/function.h:49:10: note: Assuming 'n' is < 0
   49 |   while (n >= 0) {
      |          ^~~~~~
source/function.h:49:3: note: Loop condition is false. Execution continues on line 66
   49 |   while (n >= 0) {
      |   ^
source/test.c:134:10: note: Returned allocated memory
  134 |     pT = printable((char*)T);
      |          ^~~~~~~~~~~~~~~~~~~
source/test.c:148:7: note: 'occur2' is < 0
  148 |   if (occur2 >= 0 && occur1 != occur2) {
      |       ^~~~~~
source/test.c:148:19: note: Left side of '&&' is false
  148 |   if (occur2 >= 0 && occur1 != occur2) {
      |                   ^
source/test.c:167:9: note: Assuming the condition is false
  167 |     if (VERBOSE) {
      |         ^
source/test.c:49:17: note: expanded from macro 'VERBOSE'
   49 | #define VERBOSE strcmp(parameter, "-nv")
      |                 ^~~~~~~~~~~~~~~~~~~~~~~~
source/test.c:167:5: note: Taking false branch
  167 |     if (VERBOSE) {
      |     ^
source/test.c:175:5: note: Potential leak of memory pointed to by 'pT'
  175 |   (*rip)++;
      |     ^
source/test.c:200:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  200 |   strcpy(algoname, argv[1]);
      |   ^~~~~~
source/test.c:200:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  200 |   strcpy(algoname, argv[1]);
      |   ^~~~~~
source/test.c:203:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  203 |     strcpy(parameter, argv[2]);
      |     ^~~~~~
source/test.c:203:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  203 |     strcpy(parameter, argv[2]);
      |     ^~~~~~
source/test.c:205:3: warning: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  205 |   strcat(filename, algoname);
      |   ^~~~~~
source/test.c:205:3: note: Call to function 'strcat' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcat'. CWE-119
  205 |   strcat(filename, algoname);
      |   ^~~~~~
source/test.c:364:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  364 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:364:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  364 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:365:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  365 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:365:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  365 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:373:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  373 |     strcpy((char *)P, "aa");
      |     ^~~~~~
source/test.c:373:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  373 |     strcpy((char *)P, "aa");
      |     ^~~~~~
source/test.c:374:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  374 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:374:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  374 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:381:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  381 |   strcpy((char *)P, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:381:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  381 |   strcpy((char *)P, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:382:3: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  382 |   strcpy((char *)T, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:382:3: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  382 |   strcpy((char *)T, "aaaaaaaaaa");
      |   ^~~~~~
source/test.c:389:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  389 |     strcpy((char *)P, "b");
      |     ^~~~~~
source/test.c:389:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  389 |     strcpy((char *)P, "b");
      |     ^~~~~~
source/test.c:390:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  390 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:390:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  390 |     strcpy((char *)T, "aaaaaaaaaa");
      |     ^~~~~~
source/test.c:398:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  398 |     strcpy((char *)P, "ab");
      |     ^~~~~~
source/test.c:398:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  398 |     strcpy((char *)P, "ab");
      |     ^~~~~~
source/test.c:399:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  399 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:399:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  399 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:407:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  407 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:407:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  407 |     strcpy((char *)P, "a");
      |     ^~~~~~
source/test.c:408:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  408 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:408:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  408 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:416:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  416 |     strcpy((char *)P, "aba");
      |     ^~~~~~
source/test.c:416:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  416 |     strcpy((char *)P, "aba");
      |     ^~~~~~
source/test.c:417:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  417 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:417:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  417 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:423:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  423 |     strcpy((char *)P, "abc");
      |     ^~~~~~
source/test.c:423:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  423 |     strcpy((char *)P, "abc");
      |     ^~~~~~
source/test.c:424:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  424 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:424:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  424 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:432:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  432 |     strcpy((char *)P, "ba");
      |     ^~~~~~
source/test.c:432:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  432 |     strcpy((char *)P, "ba");
      |     ^~~~~~
source/test.c:433:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  433 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:433:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  433 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:441:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  441 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:441:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  441 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:442:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  442 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:442:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  442 |     strcpy((char *)T, "ababababab");
      |     ^~~~~~
source/test.c:450:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  450 |     strcpy((char *)P, "bcdefg");
      |     ^~~~~~
source/test.c:450:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  450 |     strcpy((char *)P, "bcdefg");
      |     ^~~~~~
source/test.c:451:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  451 |     strcpy((char *)T, "bcdefghilm");
      |     ^~~~~~
source/test.c:451:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  451 |     strcpy((char *)T, "bcdefghilm");
      |     ^~~~~~
source/test.c:541:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  541 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:541:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  541 |     strcpy((char *)P, "babbbbb");
      |     ^~~~~~
source/test.c:542:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  542 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:542:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  542 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:550:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  550 |     strcpy((char *)P, "bababb");
      |     ^~~~~~
source/test.c:550:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  550 |     strcpy((char *)P, "bababb");
      |     ^~~~~~
source/test.c:551:5: warning: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119 [clang-analyzer-security.insecureAPI.strcpy]
  551 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
source/test.c:551:5: note: Call to function 'strcpy' is insecure as it does not provide bounding of the memory buffer. Replace unbounded copy functions with analogous functions that support length arguments such as 'strlcpy'. CWE-119
  551 |     strcpy((char *)T, "abababbbbb");
      |     ^~~~~~
